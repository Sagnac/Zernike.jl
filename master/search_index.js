var documenterSearchIndex = {"docs":
[{"location":"wavefront(ρ, θ, OPD, n_max)/#wavefront(ρ,-θ,-OPD,-n_max)","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"","category":"section"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"Estimates wavefront error by expressing optical aberrations as a linear combination of weighted Zernike polynomials using a linear least squares method. The accuracy of this type of wavefront reconstruction represented as an expanded series depends upon a sufficiently sampled phase field and a suitable choice of the fitting order n_max.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"ρ, θ, and OPD must be floating-point vectors of equal length; at each specific index the values are elements of an ordered triple over the exit pupil.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"ρ: normalized radial exit pupil position variable {0 ≤ ρ ≤ 1};\nθ: angular exit pupil variable in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nOPD: measured optical path difference in waves;\nn_max: maximum radial degree to fit to.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"Note that specifying n_max will fit using the full range of Zernike polynomials from j = 0 to j_max corresponding to the last polynomial with degree n_max. If instead you only want to fit to a subset of Zernike polynomials you can specify a vector of (m, n) tuples in place of n_max using the method:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"wavefront(ρ, θ, OPD, orders::Vector{Tuple{Int, Int}})","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"If your phase data is in the form of a floating-point matrix instead you can call the method:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"wavefront(OPD, fit_to; options...)","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"This assumes the wavefront error was uniformly measured using polar coordinates; the matrix is expected to be a polar grid of regularly spaced periodic samples with the first element referring to the value at the origin and the end points including the boundary of the pupil (i.e. ρ, θ = 0.0:step:1.0, 0.0:step:2π). The first axis of the matrix (the rows) must correspond to the angular variable θ while the second axis (the columns) must correspond to the radial variable ρ.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"If instead your data is not equally spaced you can call:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"wavefront(ρ::Vector, θ::Vector, OPD::Matrix, fit_to; options...)","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"under the aforementioned dimensional ordering assumption.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"fit_to can be either n_max::Int or orders::Vector{Tuple{Int, Int}}.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"It is also possible to input normalized Cartesian coordinates using the method with 3 positional arguments and passing fit_to as a keyword argument:<br> wavefront(x, y, OPD; fit_to, options...);<br> This accepts vectors and matrices for the phase; in this case, if OPD is a matrix the shape of the axes is assumed to be x-by-y.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"The function returns six values contained within a WavefrontOutput type, with fields:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"recap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients rounded according to precision;\nv: full vector of Zernike wavefront error expansion coefficients;\nssr: the sum of the squared residuals from the fit;\nmetrics: named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio;\nW: the Wavefront function ΔW(ρ, θ);\nfig: the Makie FigureAxisPlot.","category":"page"},{"location":"Options/#Options","page":"Options","title":"Options","text":"","category":"section"},{"location":"Options/","page":"Options","title":"Options","text":"There are 2 options you can vary using keyword arguments. All 3 main functions support:","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"finesse::Int: determines the size of the plot matrix; sets both dimensions to the given value.","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"Default: 1024.","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"Additionally, the wavefront error functions wavefront(ρ, θ, OPD, n_max) and transform(v, ε, δ, ϕ, ω) support:","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"precision: number of digits to use after the decimal point in computing the expansion coefficients. Results will be rounded according to this precision and any polynomials with zero-valued coefficients will be ignored when pulling in the Zernike functions while constructing the composite wavefront error; this means lower precision values yield faster results.","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"Plot options can be set by setting the Zernike.plotconfig fields; see the docstring for more details.","category":"page"},{"location":"Seidel Aberrations & Transfer Functions/#Seidel-Aberrations-and-Transfer-Functions","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"","category":"section"},{"location":"Seidel Aberrations & Transfer Functions/","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"Third-order Seidel aberrations at a fixed field can be converted to Zernike polynomials by using Wavefront(aberr::Zernike.Aberration) where the Aberration constructor accepts the standard wavefront error coefficients.","category":"page"},{"location":"Seidel Aberrations & Transfer Functions/","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"OTF(ΔW) & MTF(ΔW) yield the Optical & Modulation Transfer Functions as matrices for the input Wavefront.","category":"page"},{"location":"Seidel Aberrations & Transfer Functions/","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"The MTF can be plotted using the methods mtf_plot & mtf_plot! which accept the MTF matrix. mtf_plot(mtf) will 3D surface plot it in full, while mtf_plot(mtf, :x) & mtf_plot(mtf, :y) will plot the radial profile along a sagittal or tangential slice; the mutating version mtf_plot!(mtf, x_or_y::Symbol) allows you to superimpose a different MTF on the existing plot.","category":"page"},{"location":"Z, W, Y functions/#Z,-W,-Y-functions","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"","category":"section"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Analogs:","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Z: zernike\nW: wavefront\nY: transform","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"These methods avoid plotting and instead return (ρ, θ) functions as essentially closures, but packaged within Polynomial and Wavefront types. The pupil can then be evaluated using these functions with polar coordinates:","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Z40 = Z(0, 4)\nZ40(0.7, π/4)","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"For wavefront reconstruction this is equivalent to ΔW(ρ, θ) = ∑aᵢZᵢ(ρ, θ) where aᵢ and Zᵢ were determined from the fitting process according to precision.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Arithmetic between these types is defined using the usual operators such that wavefront error approximations essentially form a commutative ring (with associativity of multiplication being approximate) expressed in a Zernike basis.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"In addition, the Zernike.Superposition(W) and Zernike.Product(W) constructors (where W is a Vector{Wavefront}) serve as direct methods for creating composite functions which group evaluate a specified expansion set when an updated set of coefficients is not required.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Product expansion of radial polynomials can be achieved by passing an azimuthal index and a coefficient vector associated with a sequence of radial polynomials {Rₙ} to the Wavefront{RadialPolynomial} constructor and then multiplying them to yield a new series in radial polynomials. This MMT quadrature approach is based on a paper by Cadiot et al. (2024).","category":"page"},{"location":"zernike(m, n) , zernike(j)/#zernike(m,-n)-zernike(j)","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"","category":"section"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"Generates a Zernike polynomial.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"m: azimuthal order;\nn: radial degree;\nj: ANSI Z80.28-2004 / ISO 24157:2008 / Optica (OSA) standard single-mode ordering index.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"Returns a Zernike.Output type which contains (among other things):","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"Z: the Polynomial function Z(ρ, θ);\nfig: the Makie FigureAxisPlot;\ncoeffs: vector of radial polynomial coefficients;\nlatex: LaTeX string of the Zernike polynomial;\nunicode: Unicode string of the Zernike polynomial.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"The coefficients belong to terms with exponent n − 2(i − 1) where i is the vector's index.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"The radial polynomial coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a recursive relation presented by Honarvar & Paramesran (2013).","category":"page"},{"location":"Single-Index Ordering Schemes/#Single-Index-Ordering-Schemes","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"","category":"section"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"This package uses the ANSI Z80.28-2004 standard sequential ordering scheme where applicable, but provides several functions for converting between two other ordering methods, namely Noll and Fringe. The following methods are available:","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"noll_to_j(noll::Int): converts Noll indices to ANSI standard indices;\nj_to_noll(j::Int): converts ANSI standard indices to Noll indices;\nstandardize(noll::Noll): re-orders a Noll specified Zernike expansion coefficient vector according to the ANSI standard;\nfringe_to_j(fringe::Int): converts Fringe indices to ANSI standard indices; only indices 1:37 are valid;\nj_to_fringe(j::Int): converts ANSI standard indices to Fringe indices;\nstandardize(fringe::Fringe): formats a Fringe specified Zernike expansion coefficient vector according to the ANSI standard;\nstandardize(v_sub::Vector, orders::Vector{Tuple{Int, Int}}): pads a subset Zernike expansion coefficient vector to the full standard length up to n_max (1:j_max+1).","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"The Noll and Fringe types are used to wrap the input coefficient vectors for the standardize method arguments (e.g. standardize(Fringe(v::Vector{Float64}))). These can also be used to convert between the ordering schemes (e.g. Noll(fringe::Fringe), Fringe(s::Standard)).","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"The standardize fringe method expects unnormalized coefficients; the input coefficients will be re-ordered and normalized in line with the orthonormal standard. As Fringe is a 37 polynomial subset of the full set of Zernike polynomials any coefficients in the standard order missing a counterpart in the input vector will be set to zero.","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"For the standardize subset method the tuples in orders must be of the form (m, n) associated with the respective coefficients at each index in v_sub.","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"In addition, the functions get_j(m, n) & get_mn(j) allow you to convert between the single and double indices.","category":"page"},{"location":"api/#Zernike.plotconfig","page":"API","title":"Zernike.plotconfig","text":"Zernike plot settings.\n\nFields / Options:\n\nsize::Tuple{Float64, Float64}: window size (DPI scaled resolution);\nfontsize::Float64: text size;\ncolormap::Symbol: Default: :oslo;\ntheme::Makie.Attributes: Default: theme_black();\nfocus_on_show::Bool: whether the window is focused on generation (default: true).\n\nThere are two methods which can be used to trigger a settings refresh: resize! & reset!.\n\ntip: Tip\nSetting the theme to Zernike.Attributes() will use the default Makie theme.\n\nnote: Note\nThe focus_on_show attribute of plotconfig only controls whether Zernike plots will set that option of the screen configuration, but if using Makie to create other types of plots this property needs to be set using activate! or set_theme!. The Zernike.reset!(plotconfig) function will appropriately reset these along with the rest of the plotconfig.\n\nSee also: zplot.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Zernike.Gradient","page":"API","title":"Zernike.Gradient","text":"Zernike.Gradient(Z::Polynomial)\n\nReturns the gradient ∇Z(ρ, θ) in a polar basis.\n\nIf called with a complex number x + iy this function returns the vector [∂Z/∂x, ∂Z/∂y] at the point (x, y) in Cartesian coordinates instead.\n\nSee also: grad, lap, derivatives, Laplacian.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Laplacian","page":"API","title":"Zernike.Laplacian","text":"Zernike.Laplacian(Z::Polynomial)\n\nReturns the Laplacian ΔZ(ρ, θ).\n\nThis function can be evaluated in Cartesian coordinates if passed a complex number instead (i.e. ∇²Z(x, y) ≡ ΔZ(xy::Complex)).\n\nSee also: grad, lap, derivatives, Gradient.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Polynomial","page":"API","title":"Zernike.Polynomial","text":"Zernike.Polynomial\n\nCallable type: function Z(ρ, θ) bound to a given set of Zernike indices m and n.\n\nThe single argument method Zₘₙ(ρ) will radially evaluate the polynomial with angle zero.\n\nFields:\n\ninds: named tuple containing the Zernike polynomial indices;\nN: normalization factor;\nR: RadialPolynomial callable type: function R(ρ);\nM: Harmonic callable type: function M(θ).\n\nThis type can be indexed (zero-based) to return a specific radial coefficient corresponding to the term with exponent i. Calling getindex without an explicit index will return the full vector of coefficients.\n\nSee also: Zernike.Wavefront.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Standard","page":"API","title":"Zernike.Standard","text":"Standard(v::Vector{Float64})\n\nWraps a standard ANSI / ISO vector of Zernike polynomial single indices for inter-conversions, viz. Noll(s::Standard) & Fringe(s::Standard).\n\nSee also: standardize.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Wavefront","page":"API","title":"Zernike.Wavefront","text":"Zernike.Wavefront\n\nCallable type: function ΔW(ρ, θ) bound to a given set of Zernike polynomial functions Zᵢ(ρ, θ) and their corresponding expansion coefficients aᵢ.\n\nSpecifically, ΔW(ρ, θ) = ∑aᵢZᵢ(ρ, θ)\n\nThe single argument method ΔW(ρ) will radially evaluate the polynomials with angle zero.\n\nFields:\n\nrecap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients;\nv: full vector of the unfiltered full-precision standardized expansion coefficients up to n_max;\nn_max: maximum radial degree fit to;\nfit_to: vector of (m, n) tuples specifying the polynomials used for the fit;\na: vector of the Zernike expansion coefficients corresponding to each polynomial present;\nZ: the respective Zernike polynomial functions;\nprecision: the precision with which the a & Z values were determined;\nssr: the sum of the squared residuals from the fit.\n\nThe fit_to field is an empty vector if the default full range up to n_max (0:j_max) was used with no orders specified. Note that these orders could differ from the polynomials determined after the fit; they are simply what was passed to the fitting function and may refer to polynomials not present in the reconstruction if after filtering the corresponding coefficients are zero.\n\nThis type can be indexed (zero-based) to return a specific Zernike expansion coefficient corresponding to the Zernike polynomial of index j. Calling getindex without an explicit index will return the full vector of coefficients.\n\nSee also: Zernike.Polynomial.\n\n\n\nWavefront(G::Gradient{Polynomial})\n\nReturn the Zernike coefficients of the gradient as a Wavefront.\n\nSee also: grad.\n\n\n\nWavefront(L::Laplacian)\n\nReturn the Zernike coefficients of the Laplacian as a Wavefront.\n\nSee also: lap.\n\n\n\nWavefront{RadialPolynomial}(m::Int, a::Vector)\n\nConstruct a radial series in a Wavefront from an azimuthal index and a coefficient vector associated with a sequence of radial polynomials.\n\n\n\nWavefront{RadialPolynomial}(m::Int, n::Vector{Int}, a::Vector)\n\nConstruct a Wavefront radial polynomial series from an azimuthal index, a vector of radial indices, and a coefficient vector associated with them; the indices are subject to the usual restrictions for Zernike polynomials.\n\nSee also *.\n\n\n\nWavefront(aberr::Aberration)\n\nConvert a set of Seidel aberrations to Zernike polynomials.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*","page":"API","title":"Base.:*","text":"*(w1::Wavefront{T}, w2::Wavefront{T}; [threshold = 5.0E-324]) where T <: RadialPolynomial\nw1 * w2\n\nCompute the radial product expansion of two Zernike radial polynomial sequences.\n\nReturns the coefficients of the new series embedded in a Wavefront. Based on a paper by Cadiot et al. (2024) using Matrix Multiplication Transforms and their inverses to perform quadrature.\n\nThe coefficients will be filtered according to threshold, with any absolute values less than it being set to zero.\n\nSee also: Wavefront.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.MTF","page":"API","title":"Zernike.MTF","text":"MTF(ΔW::Wavefront)\n\nReturn the Modulation Transfer Function as a real valued matrix for the input Wavefront.\n\nSee also: OTF, mtf_plot, mtf_plot!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.OTF","page":"API","title":"Zernike.OTF","text":"OTF(ΔW::Wavefront)\n\nReturn the Optical Transfer Function as a complex valued matrix for the input Wavefront.\n\nSee also: MTF, mtf_plot, mtf_plot!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.S","page":"API","title":"Zernike.S","text":"S(v, ε; precision)\n\nScale the pupil over a wavefront using an algorithm based on Janssen & Dirksen's formula and return a new Wavefront.\n\nv is the set of Zernike wavefront error expansion coefficients and ε is the scaling factor.\n\nSee also: Y, scale.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.W","page":"API","title":"Zernike.W","text":"W(ρ, θ, OPD, n_max)\n\nReturn the Wavefront function ΔW(ρ, θ) corresponding to an n_max fit.\n\n\n\nW(∂x::Vector{Float64}, ∂y::Vector{Float64}; [normalized = true])\n\nCompute the original wavefront error coefficients given the Zernike expansion coefficient vectors of the partial derivatives of the wavefront error.\n\nnormalized refers to whether the derivatives are associated with unnormalized Zernike polynomials.\n\n\n\nW(∂x::Wavefront, ∂y::Wavefront)\n\nEquivalent to the above, but for input wavefronts. Useful if the derivative data was fit into a Zernike basis using W. Returns a Wavefront.\n\nSee also: Wavefront, wavefront, Z, Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.Y","page":"API","title":"Zernike.Y","text":"Y(v, ε, [δ], [ϕ], [ω])\n\nReturn the Wavefront function ΔW(ρ, θ) corresponding to the input transform parameters.\n\nSee also: transform, Z, W.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.Z","page":"API","title":"Zernike.Z","text":"Z(m, n)\n\nReturn the Zernike Polynomial function Z(ρ, θ) corresponding to indices m and n.\n\nSee also: zernike, W, Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.derivatives","page":"API","title":"Zernike.derivatives","text":"derivatives(Z::Polynomial, order::Int = 1)\n\nComputes the nth order partial derivatives of Z(ρ, θ) and returns the two-tuple (∂Z/∂ρ, ∂Z/∂θ).\n\nSee also: grad, lap, Gradient, Laplacian.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.format_strings","page":"API","title":"Zernike.format_strings","text":"format_strings(Z::AbstractPolynomial)\n\nReturn a 3-tuple with the index formatted LaTeX variable name, the full LaTeX string equation, and the Unicode string representation of the polynomial. Calling the polynomial with the String type is a shortcut which yields just the symbolic Unicode string.\n\njulia> Z(-8, 8)(String)\n\"√(18)ρ⁸sin(8θ)\"\n\n\n\nformat_strings(ΔW::Wavefront)\n\nReturn a (possibly truncated) symbolic representation of the wavefront error in a Zernike basis as a LaTeXString.\n\nSee also: print_strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.fringe_to_j","page":"API","title":"Zernike.fringe_to_j","text":"fringe_to_j(fringe::Int)\n\nConvert Fringe indices to ANSI standard indices.\n\nOnly indices 1:37 are valid.\n\nSee also: j_to_fringe, noll_to_j, j_to_noll, standardize, get_j, get_mn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_j","page":"API","title":"Zernike.get_j","text":"get_j(m::Int, n::Int)\n\nReturn the single mode-ordering index j corresponding to azimuthal & radial indices (m, n).\n\n\n\nget_j(n_max::Int)\n\nReturn the single mode-ordering index j corresponding to the maximum radial index n_max; equivalent to get_j(n_max, n_max).\n\nSee also: get_mn, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_m","page":"API","title":"Zernike.get_m","text":"get_m(j::Int)\n\nReturn the azimuthal index m given the single mode-ordering index j.\n\nSee also: get_n, get_mn, get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_mn","page":"API","title":"Zernike.get_mn","text":"get_mn(j::Int)\n\nReturn the azimuthal & radial indices (m, n) given the single mode-ordering index j.\n\nSee also: get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_n","page":"API","title":"Zernike.get_n","text":"get_n(j::Int)\n\nReturn the radial index n given the single mode-ordering index j.\n\nSee also: get_m, get_mn, get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.grad","page":"API","title":"Zernike.grad","text":"∇(Z)\ngrad(Z::Polynomial)\n\nReturn the gradient of the Zernike polynomial expressed as a Wavefront in Zernike polynomial expansion coefficients.\n\nEquivalent to:\n\nWavefront(g::Gradient{Polynomial})\nWavefront(::Type{<:Gradient}, m, n; [normalize = true])\nWavefront(::Type{<:Gradient}, j; [normalize = true])\n\nwith the last two methods allowing unnormalized input. Normalized means the polynomial is expressed as Z(ρ, θ) = N * R(ρ) * M(θ) with N being the normalization prefactor required so that π-normalized integration with respect to the areal measure of Z² over the unit disk yields unity .\n\n\n\ngrad(m, n, ::Type{Matrix{Complex}})\n\nReturn a complex matrix encoding the partial derivatives of a complex unnormalized Zernike polynomial at indices m & n.\n\nThe first two columns of the matrix refer to the x partial derivatives of Z(|m|, n) & Z(-|m|, n), respectively. Likewise, the last two columns refer to the y partial derivatives of Z(|m|, n) & Z(-|m|, n).\n\n\n\ngrad(m, n, ::Type{Vector{Complex}})\n\nConvenience method which returns the relevant sign-dependent complex gradient from the above mentioned grad(m, n, Matrix{Complex}) call.\n\n\n\ngrad(m, n, ::Type{Vector{Real}}; [normalize = true])\n\nReturn the gradient of the Zernike polynomial as a tuple of real-valued Zernike coefficient vectors.\n\n\n\n∇(W)\ngrad(W::Wavefront)\n\nComputes the gradient of the wavefront.\n\nSee also: Zernike.lap, Zernike.Gradient, Zernike.Laplacian, derivatives.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.j_to_fringe","page":"API","title":"Zernike.j_to_fringe","text":"j_to_fringe(j::Int)\n\nConvert ANSI standard indices to Fringe indices.\n\nCall fringe_to_j.(1:37) to return valid indices.\n\nSee also: fringe_to_j, noll_to_j, j_to_noll, standardize, get_j, get_mn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.j_to_noll","page":"API","title":"Zernike.j_to_noll","text":"j_to_noll(j::Int)\n\nConvert ANSI standard indices to Noll indices.\n\nSee also: noll_to_j, fringe_to_j, j_to_fringe, get_j, get_mn, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.lap","page":"API","title":"Zernike.lap","text":"lap(Z::Polynomial)\n\nReturn the Laplacian of the Zernike polynomial expressed as a Wavefront in Zernike polynomial expansion coefficients.\n\nEquivalent to:\n\nWavefront(l::Laplacian)\nWavefront(::Type{<:Laplacian}, m, n; [normalize = true])\nWavefront(::Type{<:Laplacian}, j; [normalize = true])\n\nwith the last two methods allowing unnormalized input. Normalized means the polynomial is expressed as Z(ρ, θ) = N * R(ρ) * M(θ) with N being the normalization prefactor required so that π-normalized integration with respect to the areal measure of Z² over the unit disk yields unity .\n\n\n\nlap(m, n; [normalize = true])\n\nReturn the Laplacian of the Zernike polynomial as a real-valued coefficient vector.\n\nSee also: grad, Gradient, Laplacian, derivatives.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.map_phase","page":"API","title":"Zernike.map_phase","text":"map_phase(ρ, θ, OPD)\n\nReverse dimensional coordinate transform with respect to the main wavefront error method. Returns the OPD as a matrix along with the corresponding unique coordinate vectors. Assumes uniform sampling.\n\nSee also: wavefront.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.metrics","page":"API","title":"Zernike.metrics","text":"metrics(ΔW::Wavefront)\n\nCompute wavefront error metrics. Returns a named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.mnv","page":"API","title":"Zernike.mnv","text":"mnv(v)\n\nZernike tool which takes a vector v (e.g. a vector of single-index j integers or a real or complex floating point coefficient vector) and produces a (length(v) × 3) Matrix{Number} with columns corresponding to the indices m, n, & the vector v.\n\nSee also: get_n, get_m, get_mn, get_j.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.mtf_plot","page":"API","title":"Zernike.mtf_plot","text":"mtf_plot(mtf::Matrix)\n\nPlot the Modulation Transfer Function as a three-dimensional surface plot.\n\n\n\nmtf_plot(mtf::Matrix, x_or_y::Symbol)\n\nPlot the MTF along the sagittal or tangential direction in the pupil. The input symbol must be either :x or :y corresponding to the relevant meridian.\n\nSee also: mtf_plot!, MTF, OTF, zplot, plotconfig.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.mtf_plot!","page":"API","title":"Zernike.mtf_plot!","text":"mtf_plot!(mtf::Matrix, x_or_y::Symbol)\n\nOverlay the MTF on the existing plot. The input symbol must be either :x or :y corresponding to the relevant meridian.\n\nSee also: mtf_plot, MTF, OTF, zplot, plotconfig.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.noll_to_j","page":"API","title":"Zernike.noll_to_j","text":"noll_to_j(noll::Int)\n\nConvert Noll indices to ANSI standard indices.\n\nSee also: j_to_noll, fringe_to_j, j_to_fringe, get_j, get_mn, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.print_strings","page":"API","title":"Zernike.print_strings","text":"print_strings([io::IO], j::AbstractVector; [limit = true])\n\nPrint the Unicode string representations of select Zernike polynomials; j here can be a range / vector of Zernike single indices; the output stream defaults to stdout and the vertical output is limited by your displaysize unless you pass the keyword argument limit = false.\n\n\n\nprint_strings(j_max::Int)\n\nPrint the Unicode string representations of the first j + 1 Zernike polynomials from single index 0 to j_max.\n\nSee also: format_strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.radial_coefficients","page":"API","title":"Zernike.radial_coefficients","text":"radial_coefficients(m::Int, n::Int, T::Type{<:Number} = Float64)\n\nCompute Zernike radial polynomial coefficients as type T using an algorithm based on Honarvar & Paramesran's recursive relation suitable for high orders.\n\nThe coefficients in the vector correspond to terms with powers in ascending order for a Zernike polynomial with indices m & n subject to the following requirements:\n\nn ≥ 0\n|m| ≤ n\nn ≡ m (mod 2).\n\nSee also: wavefront_coefficients, transform_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.reduce_wave","page":"API","title":"Zernike.reduce_wave","text":"reduce_wave(W::Wavefront, precision::Int)\n\nReduces Wavefront precision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.reset!","page":"API","title":"Zernike.reset!","text":"reset!(plotconfig::PlotConfig; [only_theme = false])\n\nReset all of the Zernike.plotconfig settings to their defaults.\n\nnote: Note\nThis will also reset the part of the GLMakie global / universal theme used by Zernike, particularly the window title and focus_on_show properties, until another Zernike plot is crafted. If you only want to reset the theme and keep the plotconfig intact then call with the keyword argument only_theme = true.\n\nSee also: zplot, resize!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.resize!","page":"API","title":"Zernike.resize!","text":"resize!(plotconfig::PlotConfig)\n\nReset only the size and fontsize settings for Zernike.plotconfig. This is useful if your primary monitor changes or you want to return to the automatically determined values.\n\nSee also: zplot, reset!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.scale","page":"API","title":"Zernike.scale","text":"scale(v, ε; precision, finesse)\n\nScale the pupil over a wavefront using an algorithm based on Janssen & Dirksen's formula and plot the result.\n\nv is the set of Zernike wavefront error expansion coefficients and ε is the scaling factor.\n\nSee also: transform, S.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.sieve","page":"API","title":"Zernike.sieve","text":"sieve(v::Vector{Float64}, threshold::Float64)\n\nZero out any elements lower than the threshold.\n\n\n\nsieve(a::Vector)\n\nReturn Zernike non-sequential indices and the corresponding wavefront expansion coefficients for any non-zero coefficients in the input vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.standardize","page":"API","title":"Zernike.standardize","text":"standardize(noll::Noll)\nstandardize(fringe::Fringe)\n\nFormat a Noll or Fringe specified Zernike expansion coefficient vector according to the ANSI standard.\n\nFloating-point coefficient vectors need to be wrapped in the index types (e.g. standardize(Fringe(v))).\n\nThe Fringe method expects unnormalized coefficients; the input coefficients will be re-ordered and normalized in line with the orthonormal standard. As Fringe is a 37 polynomial subset of the full set of Zernike polynomials any coefficients in the standard order missing a counterpart in the input vector will be set to zero.\n\nSee also: noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, get_j, get_mn.\n\n\n\nstandardize(v_sub::FloatVec, [j::AbstractVector{Int}])\nstandardize(v_sub::Vector, orders::Vector{Tuple{Int, Int}})\nstandardize(W::Wavefront)\n\nPad a subset Zernike expansion coefficient vector to the full standard length up to n_max (1:j_max+1).\n\nThe tuples in orders must be of the form (m, n) associated with the respective coefficients at each index in v_sub.\n\nj is a vector of single-mode ordering indices associated with the coefficients; if this is not supplied the coefficients will be assumed to be in order (0:j).\n\nThe Wavefront method pads the W.a coefficient vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.transform","page":"API","title":"Zernike.transform","text":"transform(v::Vector{T}, ε::T, [δ::Complex{T}], [ϕ::T], [ω::Tuple{T,T}]) where T <: Float64\n\nCompute a new set of Zernike wavefront error expansion coefficients under a given set of transformation factors and plot the result.\n\nAvailable transformations are scaling, translation, & rotation for circular and elliptical exit pupils. These are essentially coordinate transformations in the pupil plane over the wavefront map.\n\nMain arguments\n\nv: vector of full Zernike expansion coefficients ordered in accordance with the ANSI / OSA single index standard. This is the v vector returned by wavefront(ρ, θ, OPD, n_max);\nε: scaling factor {0 ≤ ε ≤ 1};\nδ: translational complex coordinates (displacement of the pupil center in the complex plane);\nϕ: rotation of the pupil in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nω: elliptical pupil transform parameters; 2-tuple where ω[1] is the ratio of the semi-minor axis length to the semi-major axis length of the ellipse and ω[2] is the angle defined positive counter-clockwise from the horizontal coordinate axis of the exit pupil to the minor axis of the ellipse.\n\nThe order the transformations are applied is:\nscaling –> translation –> rotation –> elliptical transform.\n\nSee also: Y, zernike, wavefront, transform_coefficients.\n\n\n\nKeyword argument options:\n\ntransform(v, ε, [δ], [ϕ], [ω]; [precision = 3], [finesse::Int])\n\nprecision: number of digits to use after the decimal point in computing the expansion coefficients. Results will be rounded according to this precision and any polynomials with zero-valued coefficients will be ignored when pulling in the Zernike functions while constructing the composite wavefront error; this means lower precision values yield faster results.\nfinesse: determines the size of the plot matrix; sets both dimensions to the given value.\n\nExtended help\n\nε = r₂/r₁ where r₂ is the new smaller radius, r₁ the original\n\nIn particular the radial variable corresponding to the rescaled exit pupil is normalized such that:\nρ = r/r₂; {0 ≤ ρ ≤ 1}\nr: radial pupil position, r₂: max. radius\nΔW₂(ρ₂, θ) = ΔW₁(ερ₂, θ)\n\nFor translation the shift must be within the bounds of the scaling applied such that:\n0.0 ≤ ε + |δ| ≤ 1.0.\n\nFor elliptical pupils (usually the result of measuring the wavefront off-axis), the semi-major axis is defined such that it equals the radius of the circle and so ω[1] is the fraction of the circular pupil covered by the semi-minor axis (this is approximated well by a cosine projection factor for angles up to 40 degrees); ω[2] is then the direction of the stretching applied under transformation in converting the ellipse to a circle before fitting the expansion coefficients.\n\nThe transformed expansion coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a formulation presented by Lundström & Unsbo (2007) doi:10.1364/JOSAA.24.000569.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.transform_coefficients","page":"API","title":"Zernike.transform_coefficients","text":"transform_coefficients(v, ε, δ, ϕ, ω)\n\nDirectly compute Zernike wavefront error expansion coefficients under pupil transformations. The argument types are the same as in transform.\n\nReturns a 2-tuple with the new coefficient vector and order n_max.\n\nSee also: transform, radial_coefficients, wavefront_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.wavefront","page":"API","title":"Zernike.wavefront","text":"wavefront(ρ, θ, OPD, n_max)\n\nFit wavefront errors up to order n_max.\n\nEstimates wavefront error by expressing optical aberrations as a linear combination of weighted Zernike polynomials using a linear least squares method. The accuracy of this type of wavefront reconstruction represented as an expanded series depends upon a sufficiently sampled phase field and a suitable choice of the fitting order n_max.\n\nMain arguments\n\nρ, θ, and OPD must be floating-point vectors of equal length; at each specific index the values are elements of an ordered triple over the exit pupil.\n\nρ: normalized radial exit pupil position variable {0 ≤ ρ ≤ 1};\nθ: angular exit pupil variable in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nOPD: measured optical path difference in waves;\nn_max: maximum radial degree to fit to.\n\nReturn values\n\nReturns six values contained within a WavefrontOutput type, with fields:\n\nrecap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients rounded according to precision;\nv: full vector of Zernike wavefront error expansion coefficients;\nssr: the sum of the squared residuals from the fit;\nmetrics: named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio;\nW: the Wavefront function ΔW(ρ, θ);\nfig: the Makie FigureAxisPlot.\n\nSee also: W, zernike, transform.\n\n\n\nwavefront(ρ, θ, OPD, orders::Vector{Tuple{Int, Int}})\n\nFit wavefront errors to specific Zernike polynomials specified in orders containing Zernike (m, n) tuples.\n\n\n\nwavefront(OPD, fit_to; options...)\n\nFitting method accepting a floating-point matrix of phase data uniformly produced in a polar coordinate system over the pupil.\n\nThe matrix is expected to be a polar grid of regularly spaced periodic samples with the first element referring to the value at the origin and the end points including the boundary of the pupil (i.e. ρ, θ = 0.0:step:1.0, 0.0:step:2π). The first axis of the matrix (the rows) must correspond to the angular variable θ while the second axis (the columns) must correspond to the radial variable ρ.\n\nfit_to can be either n_max::Int or orders::Vector{Tuple{Int, Int}}.\n\n\n\nwavefront(ρ::Vector, θ::Vector, OPD::Matrix, fit_to; options...)\n\nFitting method accepting coordinate vectors and a floating-point matrix of corresponding phase data produced in a polar coordinate system over the pupil under the aforementioned dimensional ordering assumption. This method does not assume equally spaced samples.\n\n\n\nwavefront(x, y, OPD; fit_to, options...)\n\nFitting method accepting normalized Cartesian coordinate data.\n\nIf OPD is a matrix the shape of the axes is assumed to be x-by-y.\n\n\n\nKeyword argument options:\n\nwavefront(ρ, θ, OPD, n_max; [precision = 3], [finesse::Int])\n\nprecision: number of digits to use after the decimal point in computing the expansion coefficients. Results will be rounded according to this precision and any polynomials with zero-valued coefficients will be ignored when pulling in the Zernike functions while constructing the composite wavefront error; this means lower precision values yield faster results.\nfinesse: determines the size of the plot matrix; sets both dimensions to the given value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.wavefront_coefficients","page":"API","title":"Zernike.wavefront_coefficients","text":"wavefront_coefficients(ρ, θ, OPD, n_max)\n\nReturns a 2-tuple with the full vector of Zernike expansion coefficients obtained through the least squares fit and the corresponding sum of the squared residuals.\n\nSee also: wavefront, radial_coefficients, transform_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.zernike","page":"API","title":"Zernike.zernike","text":"zernike(m, n)\nzernike(j)\n\nPlot a Zernike polynomial of azimuthal order m and radial degree n.\n\nThe single index j begins at zero and follows the ANSI Z80.28-2004 / ISO 24157:2008 / Optica (OSA) standard.\n\nReturns a Zernike.Output type which contains (among other things):\n\nZ: the Polynomial function Z(ρ, θ);\nfig: the Makie FigureAxisPlot;\ncoeffs: vector of radial polynomial coefficients;\nlatex: LaTeX string of the Zernike polynomial;\nunicode: Unicode string of the Zernike polynomial.\n\nThe coefficients belong to terms with exponent n - 2(i - 1) where i is the vector's index.\n\nThe radial polynomial coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a recursive relation presented by Honarvar & Paramesran (2013) doi:10.1364/OL.38.002487.\n\nSee also: Z, wavefront, transform, radial_coefficients.\n\n\n\nKeyword argument options:\n\nzernike(m, n; [finesse::Int = 1024])\n\nfinesse: determines the size of the plot matrix; sets both dimensions to the given value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.zplot","page":"API","title":"Zernike.zplot","text":"zplot(φ; kwargs...)\nzplot(ρ, θ, φ; kwargs...)\n\nPlot Zernike phase function types (Polynomials, Wavefronts, Derivatives, arithmetic types, etc.) as well as quantized phase arrays; for the latter the arguments must be a collection of discretized samples where the polar variable objects refer to either ranges, vectors, or 1-dimensional matrices & the like, and the phase structure φ is either an array corresponding to these samples or a callable type in which case the matrix will be constructed for you.\n\nKeyword arguments:\n\nsize::Tuple{Float64, Float64}: window size (DPI scaled resolution);\nfontsize::Float64: text size;\ncolormap::Symbol: Default: :oslo;\ntheme::Makie.Attributes: Default: theme_black();\nfocus_on_show::Bool: whether the window is focused on generation (default: true);\nwindow_title::String: window title;\nplot_title::Union{String, LaTeXString}: plot title;\nm::Int: azimuthal order (used to determine matrix size);\nn::Int: radial order (used to determine matrix size);\nfinesse::Int: determines the matrix size;\nhigh_order::Bool: whether to apply a logarithmic transform (default: false).\n\nAny keyword arguments supported by Makie's surface are also supported.\n\n\n\nPlots can be updated on demand by passing an Observable and changing its value.\n\nFor example:\n\nw = Observable(Wavefront([0.0, -1.0, 1.0]))\nzplot(w)\n\n# update\nw[] = Wavefront([0.0, 1.0, 1.0])\n\n\n\nAs a convenient shortcut any type of phase object can be plotted by simply calling it with no arguments, e.g. as w(); similarly, calling it as w(Screen) will plot it in a new window; note the first method depends on display automatically being called, while the second will explicitly call it.\n\nSee also: plotconfig.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.∇","page":"API","title":"Zernike.∇","text":"∇(Z)\ngrad(Z::Polynomial)\n\nReturn the gradient of the Zernike polynomial expressed as a Wavefront in Zernike polynomial expansion coefficients.\n\nEquivalent to:\n\nWavefront(g::Gradient{Polynomial})\nWavefront(::Type{<:Gradient}, m, n; [normalize = true])\nWavefront(::Type{<:Gradient}, j; [normalize = true])\n\nwith the last two methods allowing unnormalized input. Normalized means the polynomial is expressed as Z(ρ, θ) = N * R(ρ) * M(θ) with N being the normalization prefactor required so that π-normalized integration with respect to the areal measure of Z² over the unit disk yields unity .\n\n\n\ngrad(m, n, ::Type{Matrix{Complex}})\n\nReturn a complex matrix encoding the partial derivatives of a complex unnormalized Zernike polynomial at indices m & n.\n\nThe first two columns of the matrix refer to the x partial derivatives of Z(|m|, n) & Z(-|m|, n), respectively. Likewise, the last two columns refer to the y partial derivatives of Z(|m|, n) & Z(-|m|, n).\n\n\n\ngrad(m, n, ::Type{Vector{Complex}})\n\nConvenience method which returns the relevant sign-dependent complex gradient from the above mentioned grad(m, n, Matrix{Complex}) call.\n\n\n\ngrad(m, n, ::Type{Vector{Real}}; [normalize = true])\n\nReturn the gradient of the Zernike polynomial as a tuple of real-valued Zernike coefficient vectors.\n\n\n\n∇(W)\ngrad(W::Wavefront)\n\nComputes the gradient of the wavefront.\n\nSee also: Zernike.lap, Zernike.Gradient, Zernike.Laplacian, derivatives.\n\n\n\n\n\n","category":"function"},{"location":"Additional Notes/#Additional-Notes","page":"Additional Notes","title":"Additional Notes","text":"","category":"section"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Zernike.metrics(ΔW::Wavefront) exists;\nZernike.format_strings(Z::AbstractPolynomial) will return both the Unicode and LaTeX string representations directly;\nZernike.print_strings(j_max::Int) will print the Unicode string representations of the polynomials up to j_max;\nThe zplot function can be invoked independently using Polynomial and Wavefront function types, quantized wavefront errors, and Observables of each; the plot will update each time the Observable changes (see the docstring for more info);\nIf you resize the plot window, right clicking on the figure will resize / trim the plot automatically so that it fits within the window without extra space;\nPolynomial and Wavefront types can be indexed (zero-based) to return a specific coefficient; their full vector of coefficients can be conveniently accessed using single-argument getindex (e.g. z[], w[]);\nCallable types can be called with complex arguments as a convenient method to evaluate them in Cartesian coordinates;\nThe Zernike polynomials are currently only valid up to degree ~812 at which point the maximum coefficient approaches the maximum for double-precision floating-point numbers (~1e308);\nbecause 64-bit floats are used for an expanded range by default the coefficients are exactly accurate up to order ~47, limited by the 53-bit (~1e16) precision of the significand after which results are only approximate; if more accuracy is desired arbitrary precision or plain Ints can be specified by passing the appropriate type (Int, BigInt, BigFloat) as the third argument to Zernike.radial_coefficients;\nIf you're interested in precompiling the package into a system image in order to speed up load times please see the precompile directory (at the moment PrecompileTools or the like is not used);\nIf you're interested in only the full vector of Zernike expansion coefficients obtained through the least squares fit and want to avoid computing extra values and plotting the results you can call:","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Zernike.wavefront_coefficients(ρ, θ, OPD, n_max)","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"which will return the weights and the corresponding residual error.","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Similarly you can do this for the radial polynomial coefficients and the NA transformed wavefront error expansion coefficients by importing the functions radial_coefficients and transform_coefficients, respectively.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/#transform(v,-ε,-δ,-ϕ,-ω)","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"","category":"section"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"Pupil transform function; computes a new set of Zernike wavefront error expansion coefficients under a given set of transformation factors and plots the result.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"Available transformations are scaling, translation, & rotation for circular and elliptical exit pupils. These are essentially coordinate transformations in the pupil plane over the wavefront map.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"v::Vector{Float64}: vector of full Zernike expansion coefficients ordered in accordance with the ANSI / OSA single index standard. This is the v vector returned by wavefront(ρ, θ, OPD, n_max);\nε::Float64: scaling factor {0 ≤ ε ≤ 1};\nδ::ComplexF64: translational complex coordinates (displacement of the pupil center in the complex plane);\nϕ::Float64: rotation of the pupil in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nω::NTuple{2, Float64}: elliptical pupil transform parameters; 2-tuple where ω[1] is the ratio of the length of the semi-minor axis to the length of the semi-major axis of the ellipse and ω[2] is the angle defined positive counter-clockwise from the horizontal coordinate axis of the exit pupil to the minor axis of the ellipse.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"The order the transformations are applied is:<br> scaling –> translation –> rotation –> elliptical transform.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"The translation, rotation, and elliptical arguments are optional.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"ε = r₂/r₁ where r₂ is the new smaller radius, r₁ the original","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"In particular the radial variable corresponding to the rescaled exit pupil is normalized such that:<br> ρ = r/r₂; {0 ≤ ρ ≤ 1}<br> r: radial pupil position, r₂: max. radius<br> ΔW₂(ρ₂, θ) = ΔW₁(ερ₂, θ)","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"For translation the shift must be within the bounds of the scaling applied such that:<br> 0.0 ≤ ε + |δ| ≤ 1.0.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"For elliptical pupils (usually the result of measuring the wavefront off-axis), the semi-major axis is defined such that it equals the radius of the circle and so ω[1] is the fraction of the circular pupil covered by the semi-minor axis (this is approximated well by a cosine projection factor for angles up to 40 degrees); ω[2] is then the direction of the stretching applied under transformation in converting the ellipse to a circle before fitting the expansion coefficients.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"The transformed expansion coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a formulation presented by Lundström & Unsbo (2007).","category":"page"},{"location":"Derivatives/#Derivatives","page":"Derivatives","title":"Derivatives","text":"","category":"section"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"Zernike.derivatives(Z::Polynomial, order::Int = 1) computes the nth order partial derivatives of Z(ρ, θ) and returns the two-tuple (∂Z/∂ρ, ∂Z/∂θ) containing the Derivative types.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"Zernike.Gradient(Z::Polynomial) wraps the first-order partial derivatives and returns a callable ∇Z(ρ, θ).","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"The partials and gradient are also functors which can be evaluated over the pupil. In addition, partial derivatives can easily be plotted by simply calling them with no arguments and their Unicode representation extracted by calling them with the String type.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> ∂ρ, ∂θ = Zernike.derivatives(Z(4, 4));\n\njulia> ∂ρ(); # plots it over the pupil when not suppressed\n\njulia> ∂ρ(String)\n\"√(10)4ρ³cos(4θ)\"","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"If the expansion coefficients of the derivatives are desired instead there are several methods available:","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"Zernike.grad(Z::Polynomial) and Zernike.lap(Z::Polynomial).","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"In addition, the gradient of a Wavefront can be computed with ∇(W); this del operator / nabla symbol is an alias for grad.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"The W(∂x, ∂y) method accepts the gradient of a wavefront in a Zernike basis (e.g. the estimated Zernike expansion coefficients of the transverse aberration components from normalized Shack-Hartmann sensor data) and returns the expansion coefficients of the original wavefront error. The inputs must be in the format of 64-bit floating point vectors representing the normalized Zernike polyomial weights.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"The three algorithms which compute the expansion coefficients of the gradient, the laplacian, and the original wavefront error from the gradient are based on formulas in Janssen (2014).","category":"page"},{"location":"#Zernike.jl","page":"Home","title":"Zernike.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generates Zernike polynomials, models wavefront errors, and plots them using Makie.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Zernike.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package can be added from the Julia REPL by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/Sagnac/Zernike.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or entering the package mode by pressing ] and entering:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/Sagnac/Zernike.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"It can then be loaded by typing using Zernike.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package provides 3 main functions for modelling Zernike polynomials and wavefront errors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"zernike(m, n): Generates a Zernike polynomial, prints its symbolic representation, and plots it using GLMakie;\nwavefront(ρ, θ, OPD, n_max): Fits wavefront errors up to radial order n_max given an input set of data over the pupil, returns the Zernike expansion coefficients & various metrics, and plots the modelled wavefront error using GLMakie;\ntransform(v, ε, δ, ϕ, ω): Aperture transform function which takes a vector of Zernike expansion coefficients and a set of transformation factors and returns a new set of expansion coefficients over the transformed pupil; the wavefront error over the new pupil is also plotted using GLMakie.","category":"page"}]
}
