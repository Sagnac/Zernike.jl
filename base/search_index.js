var documenterSearchIndex = {"docs":
[{"location":"Single-Index Ordering Schemes/#Single-Index-Ordering-Schemes","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"","category":"section"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"This package uses the ANSI Z80.28-2004 standard sequential ordering scheme where applicable, but provides several functions for converting between two other ordering methods, namely Noll and Fringe. The following methods are available:","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"noll_to_j(noll::Int): converts Noll indices to ANSI standard indices;\nj_to_noll(j::Int): converts ANSI standard indices to Noll indices;\nstandardize(noll::Noll): re-orders a Noll specified Zernike expansion coefficient vector according to the ANSI standard;\nfringe_to_j(fringe::Int): converts Fringe indices to ANSI standard indices; only indices 1:37 are valid;\nj_to_fringe(j::Int): converts ANSI standard indices to Fringe indices;\nstandardize(fringe::Fringe): formats a Fringe specified Zernike expansion coefficient vector according to the ANSI standard;\nstandardize(v_sub::Vector, orders::Vector{Tuple{Int, Int}}): pads a subset Zernike expansion coefficient vector to the full standard length up to n_max (1:j_max+1).","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"The Noll and Fringe types are used to wrap the input coefficient vectors for the standardize method arguments (e.g. standardize(Fringe(v::Vector{Float64}))). These can also be used to convert between the ordering schemes (e.g. Noll(fringe::Fringe), Fringe(s::Standard)).","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"The standardize fringe method expects unnormalized coefficients; the input coefficients will be re-ordered and normalized in line with the orthonormal standard. As Fringe is a 37 polynomial subset of the full set of Zernike polynomials any coefficients in the standard order missing a counterpart in the input vector will be set to zero.","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"For the standardize subset method the tuples in orders must be of the form (m, n) associated with the respective coefficients at each index in v_sub.","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"In addition, the functions get_j(m, n) & get_mn(j) allow you to convert between the single and double indices.","category":"page"},{"location":"api/#Zernike.Gradient","page":"API","title":"Zernike.Gradient","text":"Zernike.Gradient(Z::Polynomial)\n\nReturns the gradient ∇Z(ρ, θ) in a polar basis.\n\nIf called with a complex number x + iy this function returns the vector [∂Z/∂x, ∂Z/∂y] at the point (x, y) in Cartesian coordinates instead.\n\nSee also: grad, lap, derivatives, Laplacian.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Laplacian","page":"API","title":"Zernike.Laplacian","text":"Zernike.Laplacian(Z::Polynomial)\n\nReturns the Laplacian ΔZ(ρ, θ).\n\nThis function can be evaluated in Cartesian coordinates if passed a complex number instead (i.e. ∇²Z(x, y) ≡ ΔZ(xy::Complex)).\n\nSee also: grad, lap, derivatives, Gradient.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Polynomial","page":"API","title":"Zernike.Polynomial","text":"Zernike.Polynomial\n\nCallable type: function Z(ρ, θ) bound to a given set of Zernike indices m and n.\n\nThe single argument method Zₘₙ(ρ) will radially evaluate the polynomial with angle zero.\n\nFields:\n\ninds: named tuple containing the Zernike polynomial indices;\nN: normalization factor;\nR: RadialPolynomial callable type: function R(ρ);\nM: Harmonic callable type: function M(θ).\n\nThis type can be indexed (zero-based) to return a specific radial coefficient corresponding to the term with exponent i. Calling getindex without an explicit index will return the full vector of coefficients.\n\nSee also: Zernike.Wavefront.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Standard","page":"API","title":"Zernike.Standard","text":"Standard(v::Vector{Float64})\n\nWraps a standard ANSI / ISO vector of Zernike polynomial single indices for inter-conversions, viz. Noll(s::Standard) & Fringe(s::Standard).\n\nSee also: standardize.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Wavefront","page":"API","title":"Zernike.Wavefront","text":"Zernike.Wavefront\n\nCallable type: function ΔW(ρ, θ) bound to a given set of Zernike polynomial functions Zᵢ(ρ, θ) and their corresponding expansion coefficients aᵢ.\n\nSpecifically, ΔW(ρ, θ) = ∑aᵢZᵢ(ρ, θ)\n\nThe single argument method ΔW(ρ) will radially evaluate the polynomials with angle zero.\n\nFields:\n\nrecap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients;\nv: full vector of the unfiltered full-precision standardized expansion coefficients up to n_max;\nn_max: maximum radial degree fit to;\nfit_to: vector of (m, n) tuples specifying the polynomials used for the fit;\na: vector of the Zernike expansion coefficients corresponding to each polynomial present;\nZ: the respective Zernike polynomial functions;\nprecision: the precision with which the a & Z values were determined;\nssr: the sum of the squared residuals from the fit.\n\nThe fit_to field is an empty vector if the default full range up to n_max (0:j_max) was used with no orders specified. Note that these orders could differ from the polynomials determined after the fit; they are simply what was passed to the fitting function and may refer to polynomials not present in the reconstruction if after filtering the corresponding coefficients are zero.\n\nThis type can be indexed (zero-based) to return a specific Zernike expansion coefficient corresponding to the Zernike polynomial of index j. Calling getindex without an explicit index will return the full vector of coefficients.\n\nSee also: Zernike.Polynomial.\n\n\n\nWavefront(G::Gradient{Polynomial})\n\nReturn the Zernike coefficients of the gradient as a Wavefront.\n\nSee also: grad.\n\n\n\nWavefront(L::Laplacian)\n\nReturn the Zernike coefficients of the Laplacian as a Wavefront.\n\nSee also: lap.\n\n\n\nWavefront{RadialPolynomial}(m::Int, a::Vector)\n\nConstruct a radial series in a Wavefront from an azimuthal index and a coefficient vector associated with a sequence of radial polynomials.\n\n\n\nWavefront{RadialPolynomial}(m::Int, n::Vector{Int}, a::Vector)\n\nConstruct a Wavefront radial polynomial series from an azimuthal index, a vector of radial indices, and a coefficient vector associated with them; the indices are subject to the usual restrictions for Zernike polynomials.\n\nSee also *.\n\n\n\nWavefront(aberr::Aberration)\n\nConvert a set of Seidel aberrations to Zernike polynomials.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*","page":"API","title":"Base.:*","text":"*(w1::Wavefront{T}, w2::Wavefront{T}; [threshold = 5.0E-324]) where T <: RadialPolynomial\nw1 * w2\n\nCompute the radial product expansion of two Zernike radial polynomial sequences.\n\nReturns the coefficients of the new series embedded in a Wavefront. Based on a paper by Cadiot et al. (2024) using Matrix Multiplication Transforms and their inverses to perform quadrature.\n\nThe coefficients will be filtered according to threshold, with any absolute values less than it being set to zero.\n\nSee also: Wavefront.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.MTF","page":"API","title":"Zernike.MTF","text":"MTF(ΔW::Wavefront)\n\nReturn the Modulation Transfer Function as a real valued matrix for the input Wavefront.\n\nSee also: OTF, Wavefront.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.OTF","page":"API","title":"Zernike.OTF","text":"OTF(ΔW::Wavefront)\n\nReturn the Optical Transfer Function as a complex valued matrix for the input Wavefront\n\nSee also: MTF, Wavefront.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.S","page":"API","title":"Zernike.S","text":"S(v, ε; precision)\n\nScale the pupil over a wavefront using an algorithm based on Janssen & Dirksen's formula and return a new Wavefront.\n\nv is the set of Zernike wavefront error expansion coefficients and ε is the scaling factor.\n\nSee also: Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.W","page":"API","title":"Zernike.W","text":"W(ρ, θ, OPD, n_max)\n\nReturn the Wavefront function ΔW(ρ, θ) corresponding to an n_max fit.\n\n\n\nW(∂x::Vector{Float64}, ∂y::Vector{Float64}; [normalized = true])\n\nCompute the original wavefront error coefficients given the Zernike expansion coefficient vectors of the partial derivatives of the wavefront error.\n\nnormalized refers to whether the derivatives are associated with unnormalized Zernike polynomials.\n\n\n\nW(∂x::Wavefront, ∂y::Wavefront)\n\nEquivalent to the above, but for input wavefronts. Useful if the derivative data was fit into a Zernike basis using W. Returns a Wavefront.\n\nSee also: Wavefront, Z, Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.Y","page":"API","title":"Zernike.Y","text":"Y(v, ε, [δ], [ϕ], [ω])\n\nReturn the Wavefront function ΔW(ρ, θ) corresponding to the input transform parameters.\n\nSee also: Z, W.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.Z","page":"API","title":"Zernike.Z","text":"Z(m, n)\n\nReturn the Zernike Polynomial function Z(ρ, θ) corresponding to indices m and n.\n\nSee also: W, Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.derivatives","page":"API","title":"Zernike.derivatives","text":"derivatives(Z::Polynomial, order::Int = 1)\n\nComputes the nth order partial derivatives of Z(ρ, θ) and returns the two-tuple (∂Z/∂ρ, ∂Z/∂θ).\n\nSee also: grad, lap, Gradient, Laplacian.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.format_strings","page":"API","title":"Zernike.format_strings","text":"format_strings(Z::AbstractPolynomial)\n\nReturn a 3-tuple with the index formatted LaTeX variable name, the full LaTeX string equation, and the Unicode string representation of the polynomial. Calling the polynomial with the String type is a shortcut which yields just the symbolic Unicode string.\n\njulia> Z(-8, 8)(String)\n\"√(18)ρ⁸sin(8θ)\"\n\n\n\nformat_strings(ΔW::Wavefront)\n\nReturn a (possibly truncated) symbolic representation of the wavefront error in a Zernike basis as a LaTeXString.\n\nSee also: print_strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.fringe_to_j","page":"API","title":"Zernike.fringe_to_j","text":"fringe_to_j(fringe::Int)\n\nConvert Fringe indices to ANSI standard indices.\n\nOnly indices 1:37 are valid.\n\nSee also: j_to_fringe, noll_to_j, j_to_noll, standardize, get_j, get_mn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_j","page":"API","title":"Zernike.get_j","text":"get_j(m::Int, n::Int)\n\nReturn the single mode-ordering index j corresponding to azimuthal & radial indices (m, n).\n\n\n\nget_j(n_max::Int)\n\nReturn the single mode-ordering index j corresponding to the maximum radial index n_max; equivalent to get_j(n_max, n_max).\n\nSee also: get_mn, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_m","page":"API","title":"Zernike.get_m","text":"get_m(j::Int)\n\nReturn the azimuthal index m given the single mode-ordering index j.\n\nSee also: get_n, get_mn, get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_mn","page":"API","title":"Zernike.get_mn","text":"get_mn(j::Int)\n\nReturn the azimuthal & radial indices (m, n) given the single mode-ordering index j.\n\nSee also: get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_n","page":"API","title":"Zernike.get_n","text":"get_n(j::Int)\n\nReturn the radial index n given the single mode-ordering index j.\n\nSee also: get_m, get_mn, get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.grad","page":"API","title":"Zernike.grad","text":"∇(Z)\ngrad(Z::Polynomial)\n\nReturn the gradient of the Zernike polynomial expressed as a Wavefront in Zernike polynomial expansion coefficients.\n\nEquivalent to:\n\nWavefront(g::Gradient{Polynomial})\nWavefront(::Type{<:Gradient}, m, n; [normalize = true])\nWavefront(::Type{<:Gradient}, j; [normalize = true])\n\nwith the last two methods allowing unnormalized input. Normalized means the polynomial is expressed as Z(ρ, θ) = N * R(ρ) * M(θ) with N being the normalization prefactor required so that π-normalized integration with respect to the areal measure of Z² over the unit disk yields unity .\n\n\n\ngrad(m, n, ::Type{Matrix{Complex}})\n\nReturn a complex matrix encoding the partial derivatives of a complex unnormalized Zernike polynomial at indices m & n.\n\nThe first two columns of the matrix refer to the x partial derivatives of Z(|m|, n) & Z(-|m|, n), respectively. Likewise, the last two columns refer to the y partial derivatives of Z(|m|, n) & Z(-|m|, n).\n\n\n\ngrad(m, n, ::Type{Vector{Complex}})\n\nConvenience method which returns the relevant sign-dependent complex gradient from the above mentioned grad(m, n, Matrix{Complex}) call.\n\n\n\ngrad(m, n, ::Type{Vector{Real}}; [normalize = true])\n\nReturn the gradient of the Zernike polynomial as a tuple of real-valued Zernike coefficient vectors.\n\n\n\n∇(W)\ngrad(W::Wavefront)\n\nComputes the gradient of the wavefront.\n\nSee also: Zernike.lap, Zernike.Gradient, Zernike.Laplacian, derivatives.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.j_to_fringe","page":"API","title":"Zernike.j_to_fringe","text":"j_to_fringe(j::Int)\n\nConvert ANSI standard indices to Fringe indices.\n\nCall fringe_to_j.(1:37) to return valid indices.\n\nSee also: fringe_to_j, noll_to_j, j_to_noll, standardize, get_j, get_mn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.j_to_noll","page":"API","title":"Zernike.j_to_noll","text":"j_to_noll(j::Int)\n\nConvert ANSI standard indices to Noll indices.\n\nSee also: noll_to_j, fringe_to_j, j_to_fringe, get_j, get_mn, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.lap","page":"API","title":"Zernike.lap","text":"lap(Z::Polynomial)\n\nReturn the Laplacian of the Zernike polynomial expressed as a Wavefront in Zernike polynomial expansion coefficients.\n\nEquivalent to:\n\nWavefront(l::Laplacian)\nWavefront(::Type{<:Laplacian}, m, n; [normalize = true])\nWavefront(::Type{<:Laplacian}, j; [normalize = true])\n\nwith the last two methods allowing unnormalized input. Normalized means the polynomial is expressed as Z(ρ, θ) = N * R(ρ) * M(θ) with N being the normalization prefactor required so that π-normalized integration with respect to the areal measure of Z² over the unit disk yields unity .\n\n\n\nlap(m, n; [normalize = true])\n\nReturn the Laplacian of the Zernike polynomial as a real-valued coefficient vector.\n\nSee also: grad, Gradient, Laplacian, derivatives.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.map_phase","page":"API","title":"Zernike.map_phase","text":"map_phase(ρ, θ, OPD)\n\nReverse dimensional coordinate transform with respect to the main wavefront error method. Returns the OPD as a matrix along with the corresponding unique coordinate vectors. Assumes uniform sampling.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.metrics","page":"API","title":"Zernike.metrics","text":"metrics(ΔW::Wavefront)\n\nCompute wavefront error metrics. Returns a named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.mnv","page":"API","title":"Zernike.mnv","text":"mnv(v)\n\nZernike tool which takes a vector v (e.g. a vector of single-index j integers or a real or complex floating point coefficient vector) and produces a (length(v) × 3) Matrix{Number} with columns corresponding to the indices m, n, & the vector v.\n\nSee also: get_n, get_m, get_mn, get_j.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.noll_to_j","page":"API","title":"Zernike.noll_to_j","text":"noll_to_j(noll::Int)\n\nConvert Noll indices to ANSI standard indices.\n\nSee also: j_to_noll, fringe_to_j, j_to_fringe, get_j, get_mn, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.print_strings","page":"API","title":"Zernike.print_strings","text":"print_strings([io::IO], j::AbstractVector; [limit = true])\n\nPrint the Unicode string representations of select Zernike polynomials; j here can be a range / vector of Zernike single indices; the output stream defaults to stdout and the vertical output is limited by your displaysize unless you pass the keyword argument limit = false.\n\n\n\nprint_strings(j_max::Int)\n\nPrint the Unicode string representations of the first j + 1 Zernike polynomials from single index 0 to j_max.\n\nSee also: format_strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.radial_coefficients","page":"API","title":"Zernike.radial_coefficients","text":"radial_coefficients(m::Int, n::Int, T::Type{<:Number} = Float64)\n\nCompute Zernike radial polynomial coefficients as type T using an algorithm based on Honarvar & Paramesran's recursive relation suitable for high orders.\n\nThe coefficients in the vector correspond to terms with powers in ascending order for a Zernike polynomial with indices m & n subject to the following requirements:\n\nn ≥ 0\n|m| ≤ n\nn ≡ m (mod 2).\n\nSee also: wavefront_coefficients, transform_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.reduce_wave","page":"API","title":"Zernike.reduce_wave","text":"reduce_wave(W::Wavefront, precision::Int)\n\nReduces Wavefront precision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.sieve","page":"API","title":"Zernike.sieve","text":"sieve(v::Vector{Float64}, threshold::Float64)\n\nZero out any elements lower than the threshold.\n\n\n\nsieve(a::Vector)\n\nReturn Zernike non-sequential indices and the corresponding wavefront expansion coefficients for any non-zero coefficients in the input vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.standardize","page":"API","title":"Zernike.standardize","text":"standardize(noll::Noll)\nstandardize(fringe::Fringe)\n\nFormat a Noll or Fringe specified Zernike expansion coefficient vector according to the ANSI standard.\n\nFloating-point coefficient vectors need to be wrapped in the index types (e.g. standardize(Fringe(v))).\n\nThe Fringe method expects unnormalized coefficients; the input coefficients will be re-ordered and normalized in line with the orthonormal standard. As Fringe is a 37 polynomial subset of the full set of Zernike polynomials any coefficients in the standard order missing a counterpart in the input vector will be set to zero.\n\nSee also: noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, get_j, get_mn.\n\n\n\nstandardize(v_sub::FloatVec, [j::AbstractVector{Int}])\nstandardize(v_sub::Vector, orders::Vector{Tuple{Int, Int}})\nstandardize(W::Wavefront)\n\nPad a subset Zernike expansion coefficient vector to the full standard length up to n_max (1:j_max+1).\n\nThe tuples in orders must be of the form (m, n) associated with the respective coefficients at each index in v_sub.\n\nj is a vector of single-mode ordering indices associated with the coefficients; if this is not supplied the coefficients will be assumed to be in order (0:j).\n\nThe Wavefront method pads the W.a coefficient vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.transform_coefficients","page":"API","title":"Zernike.transform_coefficients","text":"transform_coefficients(v, ε, δ, ϕ, ω)\n\nDirectly compute Zernike wavefront error expansion coefficients under pupil transformations. The argument types are the same as in transform.\n\nReturns a 2-tuple with the new coefficient vector and order n_max.\n\nSee also: radial_coefficients, wavefront_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.wavefront_coefficients","page":"API","title":"Zernike.wavefront_coefficients","text":"wavefront_coefficients(ρ, θ, OPD, n_max)\n\nReturns a 2-tuple with the full vector of Zernike expansion coefficients obtained through the least squares fit and the corresponding sum of the squared residuals.\n\nSee also: radial_coefficients, transform_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.∇","page":"API","title":"Zernike.∇","text":"∇(Z)\ngrad(Z::Polynomial)\n\nReturn the gradient of the Zernike polynomial expressed as a Wavefront in Zernike polynomial expansion coefficients.\n\nEquivalent to:\n\nWavefront(g::Gradient{Polynomial})\nWavefront(::Type{<:Gradient}, m, n; [normalize = true])\nWavefront(::Type{<:Gradient}, j; [normalize = true])\n\nwith the last two methods allowing unnormalized input. Normalized means the polynomial is expressed as Z(ρ, θ) = N * R(ρ) * M(θ) with N being the normalization prefactor required so that π-normalized integration with respect to the areal measure of Z² over the unit disk yields unity .\n\n\n\ngrad(m, n, ::Type{Matrix{Complex}})\n\nReturn a complex matrix encoding the partial derivatives of a complex unnormalized Zernike polynomial at indices m & n.\n\nThe first two columns of the matrix refer to the x partial derivatives of Z(|m|, n) & Z(-|m|, n), respectively. Likewise, the last two columns refer to the y partial derivatives of Z(|m|, n) & Z(-|m|, n).\n\n\n\ngrad(m, n, ::Type{Vector{Complex}})\n\nConvenience method which returns the relevant sign-dependent complex gradient from the above mentioned grad(m, n, Matrix{Complex}) call.\n\n\n\ngrad(m, n, ::Type{Vector{Real}}; [normalize = true])\n\nReturn the gradient of the Zernike polynomial as a tuple of real-valued Zernike coefficient vectors.\n\n\n\n∇(W)\ngrad(W::Wavefront)\n\nComputes the gradient of the wavefront.\n\nSee also: Zernike.lap, Zernike.Gradient, Zernike.Laplacian, derivatives.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives/#Derivatives","page":"Derivatives","title":"Derivatives","text":"","category":"section"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"Zernike.derivatives(Z::Polynomial, order::Int = 1) computes the nth order partial derivatives of Z(ρ, θ) and returns the two-tuple (∂Z/∂ρ, ∂Z/∂θ) containing the Derivative types.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"Zernike.Gradient(Z::Polynomial) wraps the first-order partial derivatives and returns a callable ∇Z(ρ, θ).","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"The partials and gradient are also functors which can be evaluated over the pupil. In addition, the Unicode representation of partial derivatives can be extracted by calling them with the String type.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> ∂ρ, ∂θ = Zernike.derivatives(Z(4, 4));\n\njulia> ∂ρ(String)\n\"√(10)4ρ³cos(4θ)\"","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"If the expansion coefficients of the derivatives are desired instead there are several methods available:","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"Zernike.grad(Z::Polynomial) and Zernike.lap(Z::Polynomial).","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"In addition, the gradient of a Wavefront can be computed with ∇(W); this del operator / nabla symbol is an alias for grad.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"The W(∂x, ∂y) method accepts the gradient of a wavefront in a Zernike basis (e.g. the estimated Zernike expansion coefficients of the transverse aberration components from normalized Shack-Hartmann sensor data) and returns the expansion coefficients of the original wavefront error. The inputs must be in the format of 64-bit floating point vectors representing the normalized Zernike polyomial weights.","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"The three algorithms which compute the expansion coefficients of the gradient, the laplacian, and the original wavefront error from the gradient are based on formulas in Janssen (2014).","category":"page"},{"location":"Seidel Aberrations & Transfer Functions/#Seidel-Aberrations-and-Transfer-Functions","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"","category":"section"},{"location":"Seidel Aberrations & Transfer Functions/","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"Third-order Seidel aberrations at a fixed field can be converted to Zernike polynomials by using Wavefront(aberr::Zernike.Aberration) where the Aberration constructor accepts the standard wavefront error coefficients.","category":"page"},{"location":"Seidel Aberrations & Transfer Functions/","page":"Seidel Aberrations & Transfer Functions","title":"Seidel Aberrations & Transfer Functions","text":"OTF(ΔW) & MTF(ΔW) yield the Optical & Modulation Transfer Functions as matrices for the input Wavefront.","category":"page"},{"location":"Z, W, Y functions/#Z,-W,-Y-functions","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"","category":"section"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Analogs:","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Z: Constructs a Zernike polynomial\nW: Fits wavefront errors\nY: Aperture transformation function","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"These methods return (ρ, θ) functions as essentially closures, but packaged within Polynomial and Wavefront types. The pupil can then be evaluated using these functions with polar coordinates:","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Z40 = Z(0, 4)\nZ40(0.7, π/4)","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"For wavefront reconstruction this is equivalent to ΔW(ρ, θ) = ∑aᵢZᵢ(ρ, θ) where aᵢ and Zᵢ were determined from the fitting process according to precision.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Arithmetic between these types is defined using the usual operators such that wavefront error approximations essentially form a commutative ring (with associativity of multiplication being approximate) expressed in a Zernike basis.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"In addition, the Zernike.Superposition(W) and Zernike.Product(W) constructors (where W is a Vector{Wavefront}) serve as direct methods for creating composite functions which group evaluate a specified expansion set when an updated set of coefficients is not required.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Product expansion of radial polynomials can be achieved by passing an azimuthal index and a coefficient vector associated with a sequence of radial polynomials {Rₙ} to the Wavefront{RadialPolynomial} constructor and then multiplying them to yield a new series in radial polynomials. This MMT quadrature approach is based on a paper by Cadiot et al. (2024).","category":"page"},{"location":"Additional Notes/#Additional-Notes","page":"Additional Notes","title":"Additional Notes","text":"","category":"section"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Zernike.metrics(ΔW::Wavefront) exists;\nZernike.format_strings(Z::AbstractPolynomial) will return both the Unicode and LaTeX string representations directly;\nZernike.print_strings(j_max::Int) will print the Unicode string representations of the polynomials up to j_max;\nPolynomial and Wavefront types can be indexed (zero-based) to return a specific coefficient; their full vector of coefficients can be conveniently accessed using single-argument getindex (e.g. z[], w[]);\nCallable types can be called with complex arguments as a convenient method to evaluate them in Cartesian coordinates;\nThe Zernike polynomials are currently only valid up to degree ~812 at which point the maximum coefficient approaches the maximum for double-precision floating-point numbers (~1e308);\nbecause 64-bit floats are used for an expanded range by default the coefficients are exactly accurate up to order ~47, limited by the 53-bit (~1e16) precision of the significand after which results are only approximate; if more accuracy is desired arbitrary precision or plain Ints can be specified by passing the appropriate type (Int, BigInt, BigFloat) as the third argument to Zernike.radial_coefficients;\nIf you're interested in only the full vector of Zernike expansion coefficients obtained through the least squares fit and want to avoid computing extra values you can call:","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Zernike.wavefront_coefficients(ρ, θ, OPD, n_max)","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"which will return the weights and the corresponding residual error.","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Similarly you can do this for the radial polynomial coefficients and the NA transformed wavefront error expansion coefficients by importing the functions radial_coefficients and transform_coefficients, respectively.","category":"page"},{"location":"#Zernike.jl","page":"Home","title":"Zernike.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generates Zernike polynomials & models wavefront errors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Zernike.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package can be added from the Julia REPL by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/Sagnac/Zernike.jl\", rev=\"base\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or entering the package mode by pressing ] and entering:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/Sagnac/Zernike.jl#base","category":"page"},{"location":"","page":"Home","title":"Home","text":"It can then be loaded by typing using Zernike.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This version provides 3 main functions for modelling Zernike polynomials and wavefront errors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Z(m, n): Generates a Zernike polynomial;\nW(ρ, θ, OPD, n_max): Fits wavefront errors up to radial order n_max given an input set of data over the pupil, returns the Zernike expansion coefficients wrapped in a Wavefront type;\nY(v, ε, δ, ϕ, ω): Aperture transform function which takes a vector of Zernike expansion coefficients and a set of transformation factors and returns a new set of expansion coefficients over the transformed pupil.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: see the full documentation for the stable version based on the master branch; the zernike, wavefront, and transform functions have many of the same method variants as these functions.","category":"page"}]
}
