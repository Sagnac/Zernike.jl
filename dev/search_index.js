var documenterSearchIndex = {"docs":
[{"location":"Single-Index Ordering Schemes/#Single-Index-Ordering-Schemes","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"","category":"section"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"This package uses the ANSI Z80.28-2004 standard sequential ordering scheme where applicable, but provides several functions for converting between two other ordering methods, namely Noll and Fringe. The following methods are available:","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"noll_to_j(noll::Int): converts Noll indices to ANSI standard indices;\nj_to_noll(j::Int): converts ANSI standard indices to Noll indices;\nstandardize(noll::Noll): re-orders a Noll specified Zernike expansion coefficient vector according to the ANSI standard;\nfringe_to_j(fringe::Int): converts Fringe indices to ANSI standard indices; only indices 1:37 are valid;\nj_to_fringe(j::Int): converts ANSI standard indices to Fringe indices;\nstandardize(fringe::Fringe): formats a Fringe specified Zernike expansion coefficient vector according to the ANSI standard;\nstandardize(v_sub::Vector, orders::Vector{Tuple{Int, Int}}): pads a subset Zernike expansion coefficient vector to the full standard length up to n_max (1:j_max+1).","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"The Noll and Fringe types are used to wrap the input coefficient vectors for the standardize method arguments (e.g. standardize(Fringe(v::Vector{Float64}))). These can also be used to convert between the ordering schemes (e.g. Noll(fringe::Fringe), Fringe(s::Standard)).","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"The standardize fringe method expects unnormalized coefficients; the input coefficients will be re-ordered and normalized in line with the orthonormal standard. As Fringe is a 37 polynomial subset of the full set of Zernike polynomials any coefficients in the standard order missing a counterpart in the input vector will be set to zero.","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"For the standardize subset method the tuples in orders must be of the form (m, n) associated with the respective coefficients at each index in v_sub.","category":"page"},{"location":"Single-Index Ordering Schemes/","page":"Single-Index Ordering Schemes","title":"Single-Index Ordering Schemes","text":"In addition, the functions get_j(m, n) & get_mn(j) allow you to convert between the single and double indices.","category":"page"},{"location":"api/#Zernike.plotconfig","page":"API","title":"Zernike.plotconfig","text":"Zernike plot settings.\n\nFields / Options:\n\nsize::Tuple{Float64, Float64}: window size (DPI scaled resolution);\nfontsize::Float64: text size;\ncolormap::Symbol: Default: :oslo;\nfocus_on_show::Bool: whether the window is focused on generation (default: true).\n\nThere are two methods which can be used to trigger a settings refresh: resize! & reset!.\n\nSee also: zplot.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Zernike.Gradient","page":"API","title":"Zernike.Gradient","text":"Zernike.Gradient(Z::Polynomial)\n\nReturns ∇Z(ρ, θ).\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Polynomial","page":"API","title":"Zernike.Polynomial","text":"Zernike.Polynomial\n\nCallable type: function Z(ρ, θ) bound to a given set of Zernike indices m and n.\n\nThe single argument method Zₘₙ(ρ) will radially evaluate the polynomial with angle zero.\n\nFields:\n\ninds: named tuple containing the Zernike polynomial indices;\nN: normalization factor;\nR: RadialPolynomial callable type: function R(ρ);\nM: Harmonic callable type: function M(θ).\n\nThis type can be indexed (zero-based) to return a specific radial coefficient corresponding to the term with exponent i. Calling getindex without an explicit index will return the full vector of coefficients.\n\nSee also: Zernike.WavefrontError.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.Standard","page":"API","title":"Zernike.Standard","text":"Standard(v::Vector{Float64})\n\nWraps a standard ANSI / ISO vector of Zernike polynomial single indices for inter-conversions, viz. Noll(s::Standard) & Fringe(s::Standard).\n\nSee also: standardize.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.WavefrontError","page":"API","title":"Zernike.WavefrontError","text":"Zernike.WavefrontError\n\nCallable type: function ΔW(ρ, θ) bound to a given set of Zernike polynomial functions Zᵢ(ρ, θ) and their corresponding expansion coefficients aᵢ.\n\nSpecifically, ΔW(ρ, θ) = ∑aᵢZᵢ(ρ, θ)\n\nThe single argument method ΔW(ρ) will radially evaluate the polynomials with angle zero.\n\nFields:\n\nrecap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients;\nv: full vector of the unfiltered full-precision standardized expansion coefficients up to n_max;\nn_max: maximum radial degree fit to;\nfit_to: vector of (m, n) tuples specifying the polynomials used for the fit;\na: vector of the Zernike expansion coefficients corresponding to each polynomial present;\nZ: the respective Zernike polynomial functions;\nprecision: the precision with which the a & Z values were determined;\nssr: the sum of the squared residuals from the fit.\n\nThe fit_to field is an empty vector if the default full range up to n_max (0:j_max) was used with no orders specified. Note that these orders could differ from the polynomials determined after the fit; they are simply what was passed to the fitting function and may refer to polynomials not present in the reconstruction if after filtering the corresponding coefficients are zero.\n\nThis type can be indexed (zero-based) to return a specific Zernike expansion coefficient corresponding to the Zernike polynomial of index j. Calling getindex without an explicit index will return the full vector of coefficients.\n\nSee also: Zernike.Polynomial.\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike.S","page":"API","title":"Zernike.S","text":"S(v, ε; precision)\n\nScale the pupil over a wavefront using an algorithm based on Janssen & Dirksen's formula and return a new WavefrontError.\n\nv is the set of Zernike wavefront error expansion coefficients and ε is the scaling factor.\n\nSee also: Y, scale.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.W","page":"API","title":"Zernike.W","text":"W(ρ, θ, OPD, n_max)\n\nReturn the WavefrontError function ΔW(ρ, θ) corresponding to an n_max fit.\n\nSee also: wavefront, Z, Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.Y","page":"API","title":"Zernike.Y","text":"Y(v, ε, [δ], [ϕ], [ω])\n\nReturn the WavefrontError function ΔW(ρ, θ) corresponding to the input transform parameters.\n\nSee also: transform, Z, W.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.Z","page":"API","title":"Zernike.Z","text":"Z(m, n)\n\nReturn the Zernike Polynomial function Z(ρ, θ) corresponding to indices m and n.\n\nSee also: zernike, W, Y.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.derivatives","page":"API","title":"Zernike.derivatives","text":"Zernike.derivatives(Z::Polynomial, order::Int = 1)\n\nComputes the nth order partial derivatives of Z(ρ, θ) and returns the two-tuple (∂Z/∂ρ, ∂Z/∂θ).\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.format_strings","page":"API","title":"Zernike.format_strings","text":"format_strings(Z::AbstractPolynomial)\n\nReturn a 3-tuple with the index formatted LaTeX variable name, the full LaTeX string equation, and the Unicode string representation of the polynomial.\n\njulia> name, latex, unicode = Zernike.format_strings(Z(-8, 8));\n\njulia> unicode\n\"√(18)ρ⁸sin(8θ)\"\n\nSee also: print_strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.fringe_to_j","page":"API","title":"Zernike.fringe_to_j","text":"fringe_to_j(fringe::Int)\n\nConvert Fringe indices to ANSI standard indices.\n\nOnly indices 1:37 are valid.\n\nSee also: j_to_fringe, noll_to_j, j_to_noll, standardize, get_j, get_mn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_j","page":"API","title":"Zernike.get_j","text":"get_j(m::Int, n::Int)\n\nReturn the single mode-ordering index j corresponding to azimuthal & radial indices (m, n).\n\n\n\nget_j(n_max::Int)\n\nReturn the single mode-ordering index j corresponding to the maximum radial index n_max; equivalent to get_j(n_max, n_max).\n\nSee also: get_mn, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.get_mn","page":"API","title":"Zernike.get_mn","text":"get_mn(j::Int)\n\nReturn the azimuthal & radial indices (m, n) given the single mode-ordering index j.\n\nSee also: get_j, noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.j_to_fringe","page":"API","title":"Zernike.j_to_fringe","text":"j_to_fringe(j::Int)\n\nConvert ANSI standard indices to Fringe indices.\n\nCall fringe_to_j.(1:37) to return valid indices.\n\nSee also: fringe_to_j, noll_to_j, j_to_noll, standardize, get_j, get_mn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.j_to_noll","page":"API","title":"Zernike.j_to_noll","text":"j_to_noll(j::Int)\n\nConvert ANSI standard indices to Noll indices.\n\nSee also: noll_to_j, fringe_to_j, j_to_fringe, get_j, get_mn, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.map_phase","page":"API","title":"Zernike.map_phase","text":"map_phase(ρ, θ, OPD)\n\nReverse dimensional coordinate transform with respect to the main wavefront error method. Returns the OPD as a matrix along with the corresponding unique coordinate vectors. Assumes uniform sampling.\n\nSee also: wavefront.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.metrics","page":"API","title":"Zernike.metrics","text":"metrics(ΔW::WavefrontError)\n\nCompute wavefront error metrics. Returns a named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.noll_to_j","page":"API","title":"Zernike.noll_to_j","text":"noll_to_j(noll::Int)\n\nConvert Noll indices to ANSI standard indices.\n\nSee also: j_to_noll, fringe_to_j, j_to_fringe, get_j, get_mn, standardize.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.print_strings","page":"API","title":"Zernike.print_strings","text":"print_strings([io::IO], j1::Int, j2::Int)\n\nPrint the Unicode string representations of select Zernike polynomials from single index j1 to j2.; the output stream defaults to stdout.\n\n\n\nprint_strings(j_max::Int)\n\nPrint the Unicode string representations of the first j + 1 Zernike polynomials from single index 0 to j_max.\n\nSee also: format_strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.radial_coefficients","page":"API","title":"Zernike.radial_coefficients","text":"radial_coefficients(m::Int, n::Int, T::Type{<:Number} = Float64)\n\nCompute Zernike radial polynomial coefficients as type T using an algorithm based on Honarvar & Paramesran's recursive relation suitable for high orders.\n\nThe coefficients in the vector correspond to terms with powers in ascending order for a Zernike polynomial with indices m & n subject to the following requirements:\n\nn ≥ 0\n|m| ≤ n\nn ≡ m (mod 2).\n\nSee also: wavefront_coefficients, transform_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.reduce_wave","page":"API","title":"Zernike.reduce_wave","text":"reduce_wave(W::WavefrontError, precision::Int)\n\nReduces WavefrontError precision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.reset!","page":"API","title":"Zernike.reset!","text":"reset!(plotconfig::PlotConfig)\n\nReset all of the Zernike.plotconfig settings to their defaults.\n\nSee also: zplot, resize!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.resize!","page":"API","title":"Zernike.resize!","text":"resize!(plotconfig::PlotConfig)\n\nReset only the size and fontsize settings for Zernike.plotconfig. This is useful if your primary monitor changes or you want to return to the automatically determined values.\n\nSee also: zplot, reset!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.scale","page":"API","title":"Zernike.scale","text":"scale(v, ε; precision, finesse)\n\nScale the pupil over a wavefront using an algorithm based on Janssen & Dirksen's formula and plot the result.\n\nv is the set of Zernike wavefront error expansion coefficients and ε is the scaling factor.\n\nSee also: transform, S.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.sieve","page":"API","title":"Zernike.sieve","text":"sieve(v::Vector{Float64}, threshold::Float64)\n\nZero out any elements lower than the threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.standardize","page":"API","title":"Zernike.standardize","text":"standardize(noll::Noll)\nstandardize(fringe::Fringe)\n\nFormat a Noll or Fringe specified Zernike expansion coefficient vector according to the ANSI standard.\n\nFloating-point coefficient vectors need to be wrapped in the index types (e.g. standardize(Fringe(v))).\n\nThe Fringe method expects unnormalized coefficients; the input coefficients will be re-ordered and normalized in line with the orthonormal standard. As Fringe is a 37 polynomial subset of the full set of Zernike polynomials any coefficients in the standard order missing a counterpart in the input vector will be set to zero.\n\nSee also: noll_to_j, j_to_noll, fringe_to_j, j_to_fringe, get_j, get_mn.\n\n\n\nstandardize(v_sub::FloatVec, j::AbstractVector{Int})\nstandardize(v_sub::Vector, orders::Vector{Tuple{Int, Int}})\nstandardize(W::WavefrontError)\n\nPad a subset Zernike expansion coefficient vector to the full standard length up to n_max (1:j_max+1).\n\nThe tuples in orders must be of the form (m, n) associated with the respective coefficients at each index in v_sub.\n\nj is a vector of single-mode ordering indices associated with the coefficients.\n\nThe WavefrontError method pads the W.a coefficient vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.transform","page":"API","title":"Zernike.transform","text":"transform(v::Vector{T}, ε::T, [δ::Complex{T}], [ϕ::T], [ω::Tuple{T,T}]) where T <: Float64\n\nCompute a new set of Zernike wavefront error expansion coefficients under a given set of transformation factors and plot the result.\n\nAvailable transformations are scaling, translation, & rotation for circular and elliptical exit pupils. These are essentially coordinate transformations in the pupil plane over the wavefront map.\n\nMain arguments\n\nv: vector of full Zernike expansion coefficients ordered in accordance with the ANSI / OSA single index standard. This is the v vector returned by wavefront(ρ, θ, OPD, n_max);\nε: scaling factor {0 ≤ ε ≤ 1};\nδ: translational complex coordinates (displacement of the pupil center in the complex plane);\nϕ: rotation of the pupil in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nω: elliptical pupil transform parameters; 2-tuple where ω[1] is the ratio of the minor radius to the major radius of the ellipse and ω[2] is the angle defined positive counter-clockwise from the horizontal coordinate axis of the exit pupil to the minor axis of the ellipse.\n\nThe order the transformations are applied is:\nscaling –> translation –> rotation –> elliptical transform.\n\nSee also: Y, zernike, wavefront, transform_coefficients.\n\n\n\nKeyword argument options:\n\ntransform(v, ε, [δ], [ϕ], [ω]; [precision = 3], [finesse::Int])\n\nprecision: number of digits to use after the decimal point in computing the expansion coefficients. Results will be rounded according to this precision and any polynomials with zero-valued coefficients will be ignored when pulling in the Zernike functions while constructing the composite wavefront error; this means lower precision values yield faster results.\nfinesse: {1 ≤ finesse ≤ 100}: multiplicative factor determining the size of the plotted matrix; the total number of elements is capped at 2^20 (~ 1 million).\n\nExtended help\n\nε = r₂/r₁ where r₂ is the new smaller radius, r₁ the original\n\nIn particular the radial variable corresponding to the rescaled exit pupil is normalized such that:\nρ = r/r₂; {0 ≤ ρ ≤ 1}\nr: radial pupil position, r₂: max. radius\nΔW₂(ρ₂, θ) = ΔW₁(ερ₂, θ)\n\nFor translation the shift must be within the bounds of the scaling applied such that:\n0.0 ≤ ε + |δ| ≤ 1.0.\n\nFor elliptical pupils (usually the result of measuring the wavefront off-axis), the major radius is defined such that it equals the radius of the circle and so ω[1] is the fraction of the circular pupil covered by the minor radius (this is approximated well by a cosine projection factor for angles up to 40 degrees); ω[2] is then the direction of the stretching applied under transformation in converting the ellipse to a circle before fitting the expansion coefficients.\n\nThe transformed expansion coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a formulation presented by Lundström & Unsbo (2007) doi:10.1364/JOSAA.24.000569.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.transform_coefficients","page":"API","title":"Zernike.transform_coefficients","text":"transform_coefficients(v, ε, δ, ϕ, ω)\n\nDirectly compute Zernike wavefront error expansion coefficients under pupil transformations. The argument types are the same as in transform.\n\nReturns a 2-tuple with the new coefficient vector and order n_max.\n\nSee also: transform, radial_coefficients, wavefront_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.wavefront","page":"API","title":"Zernike.wavefront","text":"wavefront(ρ, θ, OPD, n_max)\n\nFit wavefront errors up to order n_max.\n\nEstimates wavefront error by expressing optical aberrations as a linear combination of weighted Zernike polynomials using a linear least squares method. The accuracy of this type of wavefront reconstruction represented as an expanded series depends upon a sufficiently sampled phase field and a suitable choice of the fitting order n_max.\n\nMain arguments\n\nρ, θ, and OPD must be floating-point vectors of equal length; at each specific index the values are elements of an ordered triple over the exit pupil.\n\nρ: normalized radial exit pupil position variable {0 ≤ ρ ≤ 1};\nθ: angular exit pupil variable in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nOPD: measured optical path difference in waves;\nn_max: maximum radial degree to fit to.\n\nReturn values\n\nReturns eight values contained within a WavefrontOutput type, with fields:\n\nrecap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients rounded according to precision;\nv: full vector of Zernike wavefront error expansion coefficients;\nssr: the sum of the squared residuals from the fit;\nmetrics: named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio;\nW: the WavefrontError function ΔW(ρ, θ);\nfig: the plotted Makie figure;\naxis: the plot axis;\nplot: the surface plot object.\n\nSee also: W, zernike, transform.\n\n\n\nwavefront(ρ, θ, OPD, orders::Vector{Tuple{Int, Int}})\n\nFit wavefront errors to specific Zernike polynomials specified in orders containing Zernike (m, n) tuples.\n\n\n\nwavefront(OPD, fit_to; options...)\n\nFitting method accepting a floating-point matrix of phase data uniformly produced in a polar coordinate system over the pupil.\n\nThe matrix is expected to be a polar grid of regularly spaced periodic samples with the first element referring to the value at the origin and the end points including the boundary of the pupil (i.e. ρ, θ = 0.0:step:1.0, 0.0:step:2π). The first axis of the matrix (the rows) must correspond to the angular variable θ while the second axis (the columns) must correspond to the radial variable ρ.\n\nfit_to can be either n_max::Int or orders::Vector{Tuple{Int, Int}}.\n\n\n\nwavefront(ρ::Vector, θ::Vector, OPD::Matrix, fit_to; options...)\n\nFitting method accepting coordinate vectors and a floating-point matrix of corresponding phase data produced in a polar coordinate system over the pupil under the aforementioned dimensional ordering assumption. This method does not assume equally spaced samples.\n\n\n\nwavefront(x, y, OPD; fit_to, options...)\n\nFitting method accepting normalized Cartesian coordinate data.\n\n\n\nKeyword argument options:\n\nwavefront(ρ, θ, OPD, n_max; [precision = 3], [finesse::Int])\n\nprecision: number of digits to use after the decimal point in computing the expansion coefficients. Results will be rounded according to this precision and any polynomials with zero-valued coefficients will be ignored when pulling in the Zernike functions while constructing the composite wavefront error; this means lower precision values yield faster results.\nfinesse: {1 ≤ finesse ≤ 100}: multiplicative factor determining the size of the plotted matrix; the total number of elements is capped at 2^20 (~ 1 million).\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.wavefront_coefficients","page":"API","title":"Zernike.wavefront_coefficients","text":"wavefront_coefficients(ρ, θ, OPD, n_max)\n\nReturns a 2-tuple with the full vector of Zernike expansion coefficients obtained through the least squares fit and the corresponding sum of the squared residuals.\n\nSee also: wavefront, radial_coefficients, transform_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.zernike","page":"API","title":"Zernike.zernike","text":"zernike(m, n)\nzernike(j)\n\nPlot a Zernike polynomial of azimuthal order m and radial degree n.\n\nThe single index j begins at zero and follows the ANSI Z80.28-2004 / ISO 24157:2008 / Optica (OSA) standard.\n\nReturns a Zernike.Output type which contains (among other things):\n\nZ: the Polynomial function Z(ρ, θ);\nfig: the Makie figure;\ncoeffs: vector of radial polynomial coefficients;\nlatex: LaTeX string of the Zernike polynomial;\nunicode: Unicode string of the Zernike polynomial.\n\nThe coefficients belong to terms with exponent n - 2(i - 1) where i is the vector's index.\n\nThe radial polynomial coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a recursive relation presented by Honarvar & Paramesran (2013) doi:10.1364/OL.38.002487.\n\nSee also: Z, wavefront, transform, radial_coefficients.\n\n\n\nKeyword argument options:\n\nzernike(m, n; [finesse::Int = 100])\n\nfinesse: {1 ≤ finesse ≤ 100}: multiplicative factor determining the size of the plotted matrix; the total number of elements is capped at 1 million.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike.zplot","page":"API","title":"Zernike.zplot","text":"zplot(φ; kwargs...)\nzplot(ρ, θ, φ; kwargs...)\n\nPlot Zernike phase function types (Polynomials, WavefrontErrors, PartialDerivatives, arithmetic types, etc.) as well as quantized phase arrays; for the latter the arguments must be a collection of discretized samples where the polar variable objects refer to either ranges, vectors, or 1-dimensional matrices & the like, and the phase array φ is a matrix.\n\nKeyword arguments:\n\nsize::Tuple{Float64, Float64}: window size (DPI scaled resolution);\nfontsize::Float64: text size;\ncolormap::Symbol: Default: :oslo;\nfocus_on_show::Bool: whether the window is focused on generation (default: true);\nwindow_title::String: window title;\nplot_title::Union{String, LaTeXString}: plot title;\nm::Int: azimuthal order (used to determine matrix size);\nn::Int: radial order (used to determine matrix size);\nfinesse::Int: {1 ≤ finesse ≤ 100}: (used to determine matrix size);\nhigh_order::Bool: whether to apply a logarithmic transform (default: false).\n\nPlots can be updated on demand by passing an Observable and changing its value.\n\nFor example:\n\nw = Observable(WavefrontError([0.0, -1.0, 1.0]))\nzplot(w)\n\n# update\nw[] = WavefrontError([0.0, 1.0, 1.0])\n\nAs a convenient shortcut any type of phase object can be plotted by simply calling it with no arguments, e.g. as w(); similarly, calling it as w(Screen) will plot it in a new window; note the first method depends on display automatically being called, while the second will explicitly call it.\n\nSee also: plotconfig.\n\n\n\n\n\n","category":"function"},{"location":"Options/#Options","page":"Options","title":"Options","text":"","category":"section"},{"location":"Options/","page":"Options","title":"Options","text":"There are 2 options you can vary using keyword arguments. All 3 main functions support:","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"finesse::Int: {1 ≤ finesse ≤ 100}: multiplicative factor determining the size of the plotted matrix; the total number of elements is capped at 2^20 (~ 1 million) which should avoid aliasing up to ~317 radially and ~499 azimuthally.","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"Default: 100 (for zernike, proportionally scaled according to the number of polynomials for the wavefront errors).","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"In creating the plot matrix the step size / length of the variable ranges is automatically chosen such that aliasing is avoided for reasonable orders. The finesse parameter controls how fine the granularity is subsequently at the expense of performance.","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"Additionally, the wavefront error functions wavefront(ρ, θ, OPD, n_max) and transform(v, ε, δ, ϕ, ω) support:","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"precision: number of digits to use after the decimal point in computing the expansion coefficients. Results will be rounded according to this precision and any polynomials with zero-valued coefficients will be ignored when pulling in the Zernike functions while constructing the composite wavefront error; this means lower precision values yield faster results.","category":"page"},{"location":"Options/","page":"Options","title":"Options","text":"Plot options can be set by setting the Zernike.plotconfig fields; see the docstring for more details.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/#transform(v,-ε,-δ,-ϕ,-ω)","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"","category":"section"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"Pupil transform function; computes a new set of Zernike wavefront error expansion coefficients under a given set of transformation factors and plots the result.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"Available transformations are scaling, translation, & rotation for circular and elliptical exit pupils. These are essentially coordinate transformations in the pupil plane over the wavefront map.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"v::Vector{Float64}: vector of full Zernike expansion coefficients ordered in accordance with the ANSI / OSA single index standard. This is the v vector returned by wavefront(ρ, θ, OPD, n_max);\nε::Float64: scaling factor {0 ≤ ε ≤ 1};\nδ::ComplexF64: translational complex coordinates (displacement of the pupil center in the complex plane);\nϕ::Float64: rotation of the pupil in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nω::NTuple{2, Float64}: elliptical pupil transform parameters; 2-tuple where ω[1] is the ratio of the minor radius to the major radius of the ellipse and ω[2] is the angle defined positive counter-clockwise from the horizontal coordinate axis of the exit pupil to the minor axis of the ellipse.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"The order the transformations are applied is:<br> scaling –> translation –> rotation –> elliptical transform.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"The translation, rotation, and elliptical arguments are optional.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"ε = r₂/r₁ where r₂ is the new smaller radius, r₁ the original","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"In particular the radial variable corresponding to the rescaled exit pupil is normalized such that:<br> ρ = r/r₂; {0 ≤ ρ ≤ 1}<br> r: radial pupil position, r₂: max. radius<br> ΔW₂(ρ₂, θ) = ΔW₁(ερ₂, θ)","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"For translation the shift must be within the bounds of the scaling applied such that:<br> 0.0 ≤ ε + |δ| ≤ 1.0.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"For elliptical pupils (usually the result of measuring the wavefront off-axis), the major radius is defined such that it equals the radius of the circle and so ω[1] is the fraction of the circular pupil covered by the minor radius (this is approximated well by a cosine projection factor for angles up to 40 degrees); ω[2] is then the direction of the stretching applied under transformation in converting the ellipse to a circle before fitting the expansion coefficients.","category":"page"},{"location":"transform(v, ε, δ, ϕ, ω)/","page":"transform(v, ε, δ, ϕ, ω)","title":"transform(v, ε, δ, ϕ, ω)","text":"The transformed expansion coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a formulation presented by Lundström & Unsbo (2007).","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/#wavefront(ρ,-θ,-OPD,-n_max)","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"","category":"section"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"Estimates wavefront error by expressing optical aberrations as a linear combination of weighted Zernike polynomials using a linear least squares method. The accuracy of this type of wavefront reconstruction represented as an expanded series depends upon a sufficiently sampled phase field and a suitable choice of the fitting order n_max.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"ρ, θ, and OPD must be floating-point vectors of equal length; at each specific index the values are elements of an ordered triple over the exit pupil.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"ρ: normalized radial exit pupil position variable {0 ≤ ρ ≤ 1};\nθ: angular exit pupil variable in radians (mod 2π), defined positive counter-clockwise from the horizontal x-axis;\nOPD: measured optical path difference in waves;\nn_max: maximum radial degree to fit to.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"Note that specifying n_max will fit using the full range of Zernike polynomials from j = 0 to j_max corresponding to the last polynomial with degree n_max. If instead you only want to fit to a subset of Zernike polynomials you can specify a vector of (m, n) tuples in place of n_max using the method:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"wavefront(ρ, θ, OPD, orders::Vector{Tuple{Int, Int}})","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"If your phase data is in the form of a floating-point matrix instead you can call the method:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"wavefront(OPD, fit_to; options...)","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"This assumes the wavefront error was uniformly measured using polar coordinates; the matrix is expected to be a polar grid of regularly spaced periodic samples with the first element referring to the value at the origin and the end points including the boundary of the pupil (i.e. ρ, θ = 0.0:step:1.0, 0.0:step:2π). The first axis of the matrix (the rows) must correspond to the angular variable θ while the second axis (the columns) must correspond to the radial variable ρ.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"If instead your data is not equally spaced you can call:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"wavefront(ρ::Vector, θ::Vector, OPD::Matrix, fit_to; options...)","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"under the aforementioned dimensional ordering assumption.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"fit_to can be either n_max::Int or orders::Vector{Tuple{Int, Int}}.","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"It is also possible to input normalized Cartesian coordinates using the method with 3 positional arguments and passing fit_to as a keyword argument:<br> wavefront(x, y, OPD; fit_to, options...).","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"The function returns eight values contained within a WavefrontOutput type, with fields:","category":"page"},{"location":"wavefront(ρ, θ, OPD, n_max)/","page":"wavefront(ρ, θ, OPD, n_max)","title":"wavefront(ρ, θ, OPD, n_max)","text":"recap: vector of named tuples containing the Zernike polynomial indices and the corresponding expansion coefficients rounded according to precision;\nv: full vector of Zernike wavefront error expansion coefficients;\nssr: the sum of the squared residuals from the fit;\nmetrics: named 3-tuple with the peak-to-valley error, RMS wavefront error, and Strehl ratio;\nW: the WavefrontError function ΔW(ρ, θ);\nfig: the plotted Makie figure;\naxis: the plot axis;\nplot: the surface plot object.","category":"page"},{"location":"Z, W, Y functions/#Z,-W,-Y-functions","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"","category":"section"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Analogs:","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Z: zernike\nW: wavefront\nY: transform","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"These methods avoid plotting and instead return (ρ, θ) functions as essentially closures, but packaged within Polynomial and WavefrontError types. The pupil can then be evaluated using these functions with polar coordinates:","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Z40 = Z(0, 4)\nZ40(0.7, π/4)","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"For wavefront reconstruction this is equivalent to ΔW(ρ, θ) = ∑aᵢZᵢ(ρ, θ) where aᵢ and Zᵢ were determined from the fitting process according to precision.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Arithmetic between these types is defined using the usual operators such that wavefront error approximations essentially form a commutative ring (with associativity of multiplication being approximate) expressed in a Zernike basis.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"In addition, the Zernike.Superposition(W) and Zernike.Product(W) constructors (where W is a Vector{WavefrontError}) serve as direct methods for creating composite functions which group evaluate a specified expansion set when an updated set of coefficients is not required.","category":"page"},{"location":"Z, W, Y functions/#Derivatives","page":"Z, W, Y functions","title":"Derivatives","text":"","category":"section"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Zernike.derivatives(Z::Polynomial, order::Int = 1) computes the nth order partial derivatives of Z(ρ, θ) and returns the two-tuple (∂Z/∂ρ, ∂Z/∂θ) containing the PartialDerivative types.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"Zernike.Gradient(Z::Polynomial) wraps the first-order partial derivatives and returns a callable ∇Z(ρ, θ).","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"The partials and gradient are also functors which can be evaluated over the pupil. In addition, partial derivatives can easily be plotted by simply calling them with no arguments and their Unicode representation extracted by calling them with the String type.","category":"page"},{"location":"Z, W, Y functions/","page":"Z, W, Y functions","title":"Z, W, Y functions","text":"julia> ∂Z_∂ρ, ∂Z_∂θ = Zernike.derivatives(Z(4, 4));\n\njulia> ∂Z_∂ρ(); # plots it over the pupil when not suppressed\n\njulia> ∂Z_∂ρ(String)\n\"√(10)4ρ³cos(4θ)\"","category":"page"},{"location":"Additional Notes/#Additional-Notes","page":"Additional Notes","title":"Additional Notes","text":"","category":"section"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Zernike.metrics(ΔW::WavefrontError) exists;\nZernike.format_strings(Z::AbstractPolynomial) will return both the Unicode and LaTeX string representations directly;\nZernike.print_strings(j_max::Int) will print the Unicode string representations of the polynomials up to j_max;\nThe zplot function can be invoked independently using Polynomial and WavefrontError function types, quantized wavefront errors, and Observables of each; the plot will update each time the Observable changes (see the docstring for more info);\nIf you resize the plot window, right clicking on the figure will resize / trim the plot automatically so that it fits within the window without extra space;\nPolynomial and WavefrontError types can be indexed (zero-based) to return a specific coefficient; their full vector of coefficients can be conveniently accessed using single-argument getindex (e.g. z[], w[]);\nThe Zernike polynomials are currently only valid up to degree ~812 at which point the maximum coefficient approaches the maximum for double-precision floating-point numbers (~1e308);\nbecause 64-bit floats are used for an expanded range by default the coefficients are exactly accurate up to order ~47, limited by the 53-bit (~1e16) precision of the significand after which results are only approximate; if more accuracy is desired arbitrary precision or plain Ints can be specified by passing the appropriate type (Int, BigInt, BigFloat) as the third argument to Zernike.radial_coefficients;\nIf you're interested in precompiling the package into a system image in order to speed up load times please see the precompile directory (at the moment PrecompileTools or the like is not used);\nIf you're interested in only the full vector of Zernike expansion coefficients obtained through the least squares fit and want to avoid computing extra values and plotting the results you can call:","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Zernike.wavefront_coefficients(ρ, θ, OPD, n_max)","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"which will return the weights and the corresponding residual error.","category":"page"},{"location":"Additional Notes/","page":"Additional Notes","title":"Additional Notes","text":"Similarly you can do this for the radial polynomial coefficients and the NA transformed wavefront error expansion coefficients by importing the functions radial_coefficients and transform_coefficients, respectively.","category":"page"},{"location":"#Zernike.jl","page":"Home","title":"Zernike.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generates Zernike polynomials, models wavefront errors, and plots them using Makie.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Zernike.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package can be added from the Julia REPL by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/Sagnac/Zernike.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or entering the package mode by pressing ] and entering:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/Sagnac/Zernike.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"It can then be loaded by typing using Zernike.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package provides 3 main functions for modelling Zernike polynomials and wavefront errors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"zernike(m, n): Generates a Zernike polynomial, prints its symbolic representation, and plots it using GLMakie;\nwavefront(ρ, θ, OPD, n_max): Fits wavefront errors up to radial order n_max given an input set of data over the pupil, returns the Zernike expansion coefficients & various metrics, and plots the modelled wavefront error using GLMakie;\ntransform(v, ε, δ, ϕ, ω): Aperture transform function which takes a vector of Zernike expansion coefficients and a set of transformation factors and returns a new set of expansion coefficients over the transformed pupil; the wavefront error over the new pupil is also plotted using GLMakie.","category":"page"},{"location":"zernike(m, n) , zernike(j)/#zernike(m,-n)-zernike(j)","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"","category":"section"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"Generates a Zernike polynomial.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"m: azimuthal order;\nn: radial degree;\nj: ANSI Z80.28-2004 / ISO 24157:2008 / Optica (OSA) standard single-mode ordering index.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"Returns a Zernike.Output type which contains (among other things):","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"Z: the Polynomial function Z(ρ, θ);\nfig: the Makie figure;\ncoeffs: vector of radial polynomial coefficients;\nlatex: LaTeX string of the Zernike polynomial;\nunicode: Unicode string of the Zernike polynomial.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"The coefficients belong to terms with exponent n − 2(i − 1) where i is the vector's index.","category":"page"},{"location":"zernike(m, n) , zernike(j)/","page":"zernike(m, n) | zernike(j)","title":"zernike(m, n) | zernike(j)","text":"The radial polynomial coefficients are computed using a fast and accurate algorithm suitable for high orders; it is based on a recursive relation presented by Honarvar & Paramesran (2013).","category":"page"}]
}
